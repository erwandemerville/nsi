{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Num\u00e9rique et sciences informatiques","text":""},{"location":"#nsi-premiere","title":"NSI premi\u00e8re","text":"Liste des cours Contenu Algorithmes de tri Tri par s\u00e9lection et par insertion."},{"location":"#nsi-terminale","title":"NSI terminale","text":"Liste des cours Contenu Les arbres Arbres, arbres binaires et arbres binaires de recherche."},{"location":"premiere/tris/","title":"Tri par s\u00e9lection et par insertion","text":"<p>Bienvenue, ce site est d\u00e9di\u00e9 au cours de premi\u00e8re NSI sur le tri par s\u00e9lection et par insertion.</p> <ul> <li>COURS :<ul> <li>Cours tri par s\u00e9lection</li> <li>Cours tri par insertion</li> </ul> </li> <li>\u00c9VALUATIONS :<ul> <li>Interro tri par s\u00e9lection</li> <li>Correction interro tri par s\u00e9lection</li> </ul> </li> </ul> <p>Demerville Erwan</p> <p>Me contacter : demerville.erwan@gmail.com</p>"},{"location":"premiere/tris/activite_preliminaire/","title":"Activit\u00e9 pr\u00e9liminaire sur les tris","text":"<p>L'objectif de cette activit\u00e9 est de d\u00e9terminer une strat\u00e9gie claire et pr\u00e9cise permettant, \u00e0 partir d'une suite de cartes arbitrairement choisies, d\u2019obtenir une suite de cartes tri\u00e9es dans l'ordre croissant suivant leur valeur faciale \u00e0 la fin du processus.</p> <p>On ne se souciera ici que des valeurs des cartes et non de leurs couleurs.</p> <p>Voici l'ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte, que l'on utilisera : </p> <p>Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.</p>"},{"location":"premiere/tris/activite_preliminaire/#partie-1-experimentation","title":"Partie 1 : Exp\u00e9rimentation","text":"<p>La zone de jeu est constitu\u00e9e :</p> <ul> <li>d'une suite de 8 cartes auxquelles sont associ\u00e9es un indice de 0 \u00e0 7,</li> <li>d'une zone temporaire dans laquelle on peut stocker l'indice ou la valeur d'une carte.</li> </ul> <p> </p> Zone de jeu <p>\u00c0 faire</p> <p>Par groupes de 2 \u00e0 3 personnes, vous devez :</p> <ul> <li>Disposer une suite de 8 cartes arbitrairement choisies sur votre table.</li> <li>\u00c9tablir, \u00e0 l'\u00e9crit, une suite d'instructions \u00ab en fran\u00e7ais \u00bb permettant de trier ces cartes dans l'ordre croissant. Votre strat\u00e9gie doit pouvoir \u00eatre reproduite sur n'importe quelle suite de cartes.Vous l'\u00e9crirez sur un bloc-note https://collab.infoforall.fr/.</li> <li>Tester votre strat\u00e9gie sur diff\u00e9rentes suites de cartes et vous assurer qu'elle fonctionne toujours.</li> </ul> <p>Important</p> <p>Les seules op\u00e9rations \u00e9l\u00e9mentaires autoris\u00e9es sont les suivantes :</p> <ul> <li>comparer les valeurs de deux cartes,</li> <li>permuter (\u00e9changer) deux cartes,</li> <li>copier l'indice ou la valeur d'une carte de la suite dans la zone temporaire (et inversement),</li> <li>vous pouvez utiliser des conditions (SI ..., SINON) et des boucles (TANT QUE, POUR ... ALLANT DE ... A ...).</li> </ul> <p>Voici \u00e9galement quelques r\u00e8gles \u00e0 respecter :</p> <ul> <li>vous ne pouvez parcourir les cartes que de la gauche vers la droite (on ne revient pas en arri\u00e8re),</li> <li>si une t\u00e2che est r\u00e9p\u00e9titive, vous pouvez la nommer (cr\u00e9er un autre bloc d'instructions qui sera utilis\u00e9 dans le bloc principal),</li> <li>votre strat\u00e9gie doit \u00eatre suffisamment claire, mais vous n'avez pas obligation d'\u00e9crire un algorithme formel.</li> </ul>"},{"location":"premiere/tris/activite_preliminaire/#partie-2-bilan-des-strategies","title":"Partie 2 : Bilan des strat\u00e9gies","text":"<p>Afin de s'assurer de la clart\u00e9 de chaque strat\u00e9gie, chaque groupe tentera \u00e0 pr\u00e9sent de trier une suite de 8 cartes arbitrairement choisies en utilisant les strat\u00e9gies propos\u00e9es par les autres groupes.</p> <p>\u00c0 faire</p> <p>Par groupes de 2 \u00e0 3 personnes, vous devez :</p> <ul> <li>D\u00e9rouler les instructions propos\u00e9es par les autres groupes sur des suites de 8 cartes choisies arbitrairement.</li> <li>Indiquer quelles sont les strat\u00e9gies qui fonctionnent, et celles qui ne fonctionnent pas.</li> </ul>"},{"location":"premiere/tris/activite_preliminaire/#partie-3-tri-par-selection","title":"Partie 3 : Tri par s\u00e9lection","text":"Principe du tri par s\u00e9lection <p>Le tri par s\u00e9lection se d\u00e9roule comme suit :</p> <ol> <li>Chercher l'indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier. La premi\u00e8re carte est maintenant la plus faible.</li> <li>Chercher l'indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me. Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es.</li> <li>Poursuivre ainsi jusqu\u2019\u00e0 l\u2019avant derni\u00e8re carte de la liste.</li> </ol> <p>Note : Si la valeur la plus faible des cartes de la suite est associ\u00e9e \u00e0 plusieurs cartes, on consid\u00e8rera que la plus faible carte est la premi\u00e8re (en parcourant de gauche \u00e0 droite) ayant cette valeur.</p> <p>\u00c0 faire 1</p> <p>D\u00e9rouler la m\u00e9thode de tri par s\u00e9lection d\u00e9crite ci-dessus, avec une approche humaine d'abord, sur une suites de 8 cartes arbitrairement choisies afin de v\u00e9rifier son bon fonctionnement.</p> <p>On a ici exp\u00e9riment\u00e9 la m\u00e9thode de tri par s\u00e9lection avec une approche humaine, c'est-\u00e0-dire que vous avez utilis\u00e9 votre cerveau pour d\u00e9terminer facilement, \u00e0 chaque \u00e9tape, la carte la plus faible de la suite.</p> <p>Toutefois, en raisonnant avec une d\u00e9marche plus proche de la machine, la recherche de la carte la plus faible doit se d\u00e9composer en op\u00e9rations \u00e9l\u00e9mentaires, incluant notamment des affectations, des comparaisons et des conditions.</p> Recherche de la plus faible carte <p>Pour rechercher la plus faible carte de la suite de cartes \u00e0 partir d'un indice \\(i\\) donn\u00e9 :</p> <ol> <li>Stocker l'indice \\(i\\) dans la zone temporaire.</li> <li>En parcourant la suite de cartes de gauche \u00e0 droite, \u00e0 partir de l'indice \\(i + 1\\) et jusqu'au bout de la suite :<ul> <li>Comparer les valeurs de chaque carte de la suite avec la valeur de la carte dont l'indice est stock\u00e9 dans la zone temporaire.</li> <li><code>SI</code> une carte de la suite a une valeur strictement inf\u00e9rieure \u00e0 la valeur de la carte dont l'indice est stock\u00e9 dans la zone temporaire, remplacer l'ancien indice stock\u00e9 dans la zone temporaire par l'indice de cette carte.</li> </ul> </li> <li><code>Renvoyer</code> enfin l'indice contenu dans la zone temporaire.</li> </ol> <p>\u00c0 faire 2</p> <p>Vous devez \u00e0 pr\u00e9sent :</p> <ul> <li>D\u00e9rouler de nouveau la m\u00e9thode de tri par s\u00e9lection, en d\u00e9composant la recherche de la carte la plus faible comme d\u00e9crit ci-dessus, sur plusieurs suites de 8 cartes arbitrairement choisies.</li> <li>Calculer, pour chaque suite de cartes, le nombre total de comparaisons de deux cartes ayant \u00e9t\u00e9 effectu\u00e9es.</li> <li>Que pouvez-vous en dire sur le co\u00fbt de ce tri ? Est-ce un tri efficace ?</li> </ul>"},{"location":"premiere/tris/de_cote/","title":"De cote","text":""},{"location":"premiere/tris/de_cote/#lalgorithme-tri-insertion","title":"L'algorithme (tri insertion)","text":"<p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Fonction tri_par_insertion(Tableau T)     Pour i de 1 \u00e0 taille(T) - 1         valeur_courante = T[i]         position = i</p> <pre><code>    # D\u00e9terminer la position de l'\u00e9l\u00e9ment \u00e0 placer (valeur_courante)\n    Tant que position &gt; 0 et T[position - 1] &gt; valeur_courante\n        T[position] = T[position - 1]\n        position = position - 1\n\n    T[position] = valeur_courante  # Placer l'\u00e9l\u00e9ment au bon endroit\nFin Pour\n</code></pre> <p>Fin Fonction</p> <p>Ce que fait cet algorithme, c'est qu'il it\u00e8re sur chaque \u00e9l\u00e9ment du tableau. Pour chaque \u00e9l\u00e9ment, il trouve sa position correcte parmi les \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s \u00e0 sa gauche en d\u00e9pla\u00e7ant tous les \u00e9l\u00e9ments vers la droite jusqu'\u00e0 ce qu'il trouve la bonne position, puis il ins\u00e8re l'\u00e9l\u00e9ment \u00e0 cette position. Cela continue jusqu'\u00e0 ce que tout le tableau soit tri\u00e9.</p> <pre><code>i est l'indice (fl\u00e8che en vert clair dans l'animation) de la cl\u00e9-valeur qu'il faut placer\n\nPOUR i variant de 1 \u00e0 (longueur - 1) inclus\n\n    cle \u2190 t[i]\n\n    on m\u00e9morise dans cle la valeur-cl\u00e9 car cette case risque d'\u00eatre \u00e9cras\u00e9e\n\n    j \u2190 i - 1\n\n    La variable j contient initialement l'indice juste \u00e0 gauche de la cl\u00e9 (fl\u00e8che verte dans l'animation)\n\n    TANT QUE j \u2265 0 et que t[j] &gt; cle\n\n        t[j+1] \u2190 t[j]\n\n        On d\u00e9cale la valeur d'une case \u00e0 droite\n\n        j \u2190 j - 1\n\n        On passe \u00e0 la case suivante \u00e0 gauche\n\n    Fin TANT QUE\n\n    t[j+1] \u2190 cle\n\n    On place la valeur-cl\u00e9 \u00e0 la place voulue pour obtenir un sous-tableau tri\u00e9\n\nFin POUR\n\nRenvoyer VIDE (\u2205)\n</code></pre>"},{"location":"premiere/tris/tri_insertion/","title":"Le tri par insertion","text":"<p>Nous avons vu la m\u00e9thode de tri par s\u00e9lection, qui a l'avantage d'\u00eatre facile \u00e0 appr\u00e9hender, mais qui s'av\u00e8re \u00eatre fortement co\u00fbteuse (co\u00fbt quadratique dans tous les cas). Voyons s'il n'existe pas d'autres algorithmes de tri plus int\u00e9ressants.</p>"},{"location":"premiere/tris/tri_insertion/#presentation-du-tri-par-insertion","title":"Pr\u00e9sentation du tri par insertion","text":""},{"location":"premiere/tris/tri_insertion/#avec-un-jeu-de-cartes","title":"Avec un jeu de cartes","text":"<p>Le tri par insertion est un autre algorithme de tri par comparaisons, dont le principe est un peu diff\u00e9rent, mais plus \"naturel\".</p> <p>Dans cette partie, on verra comment trier une suite de cartes en utilisant la m\u00e9thode de tri par insertion. On utilisera l'ordre suivant (de la carte la plus faible \u00e0 la plus forte) :</p> <p></p> <p>Note : Si vous avez une carte Joker dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.</p> <p>Activit\u00e9 pr\u00e9liminaire</p> <p>Munissez-vous d'un paquet de carte, m\u00e9langez-le, et placez-le en face cach\u00e9e. Vous disposez d'une zone de jeu dans laquelle vous ajouterez les cartes une par une, de mani\u00e8re \u00e0 toujours avoir une suite de cartes tri\u00e9e. L'objectif est de trier les 7 premi\u00e8res cartes du paquet.</p> <ul> <li>Prenez la premi\u00e8re carte du paquet et posez-la (face visible) dans votre zone de jeu. La suite de cartes de votre zone de jeu (compos\u00e9e pour le moment d'une seule carte) est-elle tri\u00e9e ?</li> <li>Prenez la deuxi\u00e8me carte du paquet, et int\u00e9grez-la \u00e0 votre suite de cartes de mani\u00e8re \u00e0 ce que celle-ci reste tri\u00e9e.</li> <li>Prenez la troisi\u00e8me carte du paquet et faites de m\u00eame. R\u00e9p\u00e9tez cela jusqu'\u00e0 avoir une suite de 7 cartes tri\u00e9es dans votre zone de jeu.</li> </ul> <p>Question : D\u00e9crivez la m\u00e9thode que vous avez suivi pour int\u00e9grer chaque nouvelle carte \u00e0 votre suite de cartes tri\u00e9e.</p> <p>Voici le d\u00e9roulement de la m\u00e9thode de tri par insertion sur une suite de cartes. On souhaite trier la suite de cartes suivantes :</p> <p> Une suite de 5 cartes. <p></p> <p>Composition du tableau</p> <p>On distingue deux parties dans le tableau :</p> <ul> <li>une partie tri\u00e9e (en vert), initialement compos\u00e9e de la premi\u00e8re carte.</li> <li>une partie non-tri\u00e9e (en gris), initialement compos\u00e9e du reste des cartes.</li> </ul> <p>On dispose \u00e9galement d'une zone m\u00e9moire dans laquelle peut placer une carte temporairement.</p> <p> </p> <p>On commence donc par traiter la deuxi\u00e8me carte du tableau, qui est la premi\u00e8re carte de la partie non-tri\u00e9e. On place cette carte dans la zone m\u00e9moire.</p> <p> </p> <p>Ensuite, on proc\u00e8de comme suit :</p> <p>Placer la carte \u00e0 sa bonne position</p> <ul> <li>En partant de la carte positionn\u00e9e juste \u00e0 gauche de celle que l'on cherche \u00e0 trier (c'est-\u00e0-dire la derni\u00e8re carte de la partie tri\u00e9e du tableau), et en allant jusqu'\u00e0 la premi\u00e8re carte du tableau :<ul> <li>On d\u00e9cale d'une position \u00e0 droite chaque carte dont la valeur est strictement sup\u00e9rieure \u00e0 la carte que l'on cherche \u00e0 replacer.</li> <li>On s'arr\u00eate uniquement si la carte n'a pas une valeur sup\u00e9rieure, ou si l'on a parcouru toutes les cartes.</li> </ul> </li> <li>On replace la carte (actuellement en m\u00e9moire) \u00e0 sa bonne position.</li> </ul> <p>Ici, la carte qui pr\u00e9c\u00e8de celle \u00e0 replacer (qui se trouve en m\u00e9moire) est inf\u00e9rieure \u00e0 la carte \u00e0 replacer. Cela signifie que notre carte est d\u00e9j\u00e0 \u00e0 sa bonne position.</p> <p>Il n'y a donc pas de d\u00e9calage \u00e0 faire, et on replace la carte \u00e0 sa position initiale.</p> <p> </p> <p>La partie tri\u00e9e de notre tableau est maintenant compos\u00e9e des deux premi\u00e8res cartes.</p> <p> </p> <p>On fait de m\u00eame avec la troisi\u00e8me carte du tableau (premi\u00e8re carte de la partie non-tri\u00e9e).</p> <p> </p> <p>Ici encore, la carte \u00e9tait d\u00e9j\u00e0 \u00e0 sa bonne position.</p> <p> </p> <p>On a maintenant 3 cartes dans la partie tri\u00e9e du tableau. On met la quatri\u00e8me carte (de valeur 3) en m\u00e9moire.</p> <p> </p> <p>On constate que les deux cartes pr\u00e9c\u00e9dentes (de valeurs 8 et 4) ont une valeur sup\u00e9rieure \u00e0 celle de la carte que l'on souhaite trier. Il faut donc d\u00e9placer \u00e0 droite ces deux cartes.</p> <p> </p> <p> </p> <p>On peut maintenant repositionner notre carte.</p> <p> </p> <p> </p> <p>Il ne reste ainsi plus qu'une seule carte dans la partie non-tri\u00e9e de notre tableau.</p> <p>On r\u00e9p\u00e8te le m\u00eame principe, on place cette carte en m\u00e9moire.</p> <p> </p> <p>Ici, il n'y a que la carte pr\u00e9c\u00e9dente \u00e0 d\u00e9placer.</p> <p> </p> <p>Puis on repositionne notre carte.</p> <p> </p> <p>Et voil\u00e0, on vient de trier une suite de 5 cartes par la m\u00e9thode de tri par insertion !</p> <p>\u00c0 vous de jouer</p> <p>Disposez une suite de 7 cartes choisies au hasard dans un paquet de cartes. Votre zone de jeu est compos\u00e9e de votre suite de cartes et d'un emplacement m\u00e9moire. Effectuez le tri de votre suite de cartes en utilisant la m\u00e9thode de tri par insertion pr\u00e9sent\u00e9e ci-dessus.</p>"},{"location":"premiere/tris/tri_insertion/#trier-un-tableau","title":"Trier un tableau","text":"<p>On a donc vu que la m\u00e9thode de tri par insertion avait l'avantage d'\u00eatre assez naturelle, raison pour laquelle elle est souvent utilis\u00e9e pour trier des cartes \u00e0 jouer.</p> <p>Appliquons \u00e0 pr\u00e9sent ce tri sur des tableaux d'entiers.</p> <p>On rappelle le principe du tri par insertion :</p> <ul> <li>on fait comme si les \u00e9l\u00e9ments de la partie non-tri\u00e9e du tableau \u00e9taient donn\u00e9s un par un, le premier \u00e9l\u00e9ment du tableau constituant, \u00e0 lui seul, un tableau tri\u00e9e de longueur 1,</li> <li>on y range ensuite le deuxi\u00e8me \u00e9l\u00e9ment du tableau pour constituer un tableau tri\u00e9 de longueur 2,</li> <li>puis on y range le troisi\u00e8me \u00e9l\u00e9ment pour obtenir un tableau tri\u00e9 longueur 3,</li> <li>et ainsi de suite jusqu\u2019\u00e0 avoir trait\u00e9 le dernier \u00e9l\u00e9ment...</li> </ul> <p>On ins\u00e8re donc \u00e0 la ni\u00e8me it\u00e9ration le ni\u00e8me \u00e9l\u00e9ment \u00e0 sa bonne position en d\u00e9calant \u00e0 droite tous les \u00e9l\u00e9ments de la partie tri\u00e9e du tableau qui lui sont sup\u00e9rieurs.</p> <p>Exercice - Trier un tableau</p> <p>On souhaite trier le tableau suivant avec le tri par insertion : <code>[5, 3, 1, 4, 6, 2]</code>. Indiquez quel est l'\u00e9tat du tableau apr\u00e8s chaque insertion d'\u00e9l\u00e9ment.</p> <p> Source : http://fractale.gecif.net/nsi/pdf/cours/algorithmes/algo_tri.pdf </p> <p>Faites de m\u00eame avec le tableau <code>[2,8,1,5,2,3]</code>.</p>"},{"location":"premiere/tris/tri_insertion/#lalgorithme","title":"L'algorithme","text":""},{"location":"premiere/tris/tri_insertion/#presentation-de-lalgorithme","title":"Pr\u00e9sentation de l'algorithme","text":"<p>Note</p> <p>Dans la partie pr\u00e9c\u00e9dente, on a souvent parl\u00e9 de \"d\u00e9placements\" de cartes. En machine, ces d\u00e9placements seront impl\u00e9ment\u00e9s sous la forme de copies d'\u00e9l\u00e9ments, en r\u00e9alisant des affectations.</p> <p>Algorithme du tri par insertion</p> <p> ALGORITHME : tri_insertion ENTR\u00c9E : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments SORTIE : aucune (tri en place) <p>D\u00c9BUT POUR i ALLANT DE 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003\u2003cle \u2190 tableau[i] \u2003\u2003\u2003\u2003j \u2190 i \\(-\\) 1 TANT QUE j \u2265 0 ET QUE tableau[j] &gt; cle \u2003\u2003\u2003\u2003\u2003\u2003tableau[j + 1] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003j \u2190 j \\(-\\) 1 FIN TANT QUE \u2003\u2003\u2003\u2003tableau[j + 1] \u2190 cle FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME </p> <p>Exercice 1</p> <p>D\u00e9roulez l'algorithme sur le tableau <code>[5, 3, 1, 4, 6, 2]</code>.</p> <p>Exercice 2</p> <ol> <li>Pourquoi commence t-on la boucle POUR \u00e0 partir de 1 ?</li> <li>Expliquez \u00e0 quoi sert la 3\u00e8me ligne de l'algorithme : <code>j \u2190 i - 1</code>.</li> <li>Dans le TANT QUE, \u00e0 quoi sert la premi\u00e8re condition <code>j \u2265 0</code> ? La deuxi\u00e8me condition <code>tableau[j] &gt; cle</code> ? Pourrait t-on inverser les deux conditions ?</li> <li>\u00c0 quoi sert la ligne <code>tableau[j + 1] \u2190 tableau[j]</code> dans le TANT QUE ?</li> <li>Pourquoi d\u00e9cr\u00e9mente t-on (c'est-\u00e0-dire que l'on diminue de 1) la valeur de <code>j</code> \u00e0 chaque tour de la boucle TANT QUE ?</li> <li>Expliquez l'affectation <code>tableau[j + 1] \u2190 cle</code> apr\u00e8s la boucle TANT QUE.</li> </ol> <p>Tri stable</p> <p>Le tri par insertion, \u00e9crit comme ci-dessus, est dit \"stable\" car, en cas de valeurs identiques dans le tableau initial, leur ordre relatif n\u2019est pas modifi\u00e9.</p>"},{"location":"premiere/tris/tri_insertion/#une-petite-animation","title":"Une petite animation","text":"<p>Simulation du tri par insertion</p> <p>En vert : \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s En gris : \u00e9l\u00e9ments \u00e0 trier  Espace m\u00e9moire: Lancer le tri Pas \u00e0 pas </p>"},{"location":"premiere/tris/tri_insertion/#implementation-en-python","title":"Impl\u00e9mentation en Python","text":"<p>Maintenant que l'on a d\u00e9termin\u00e9 l'algorithme du tri par insertion, on peut l'impl\u00e9menter en Python.</p> <p>T\u00e9l\u00e9chargez le programme squelette (\u00e0 compl\u00e9ter) ci-dessous.</p> <p>Fichiers Python</p> <ul> <li>tri_insertion.py : programme Python avec les fonctions \u00e0 compl\u00e9ter.</li> <li>(\u00e0 venir) : programme Python corrig\u00e9.</li> </ul> <p>Module doctest</p> <p>Dans la docstring de la fonction <code>tri_insertion</code>, des tests sont pr\u00e9sents. Ces tests sont ex\u00e9cut\u00e9s par le module natif doctest. Lorsque vous ex\u00e9cutez le programme, si les tests r\u00e9ussissent, rien ne se passera. Sinon, vous obtiendrez des informations sur les tests qui ont \u00e9chou\u00e9.</p> <p>La fonction <code>testmod</code> (qui ex\u00e9cute les tests) est appel\u00e9e dans la derni\u00e8re ligne du programme. Pour obtenir davantage d'informations sur les erreurs li\u00e9es aux tests, vous pouvez activer le mode verbeux en rempla\u00e7ant le param\u00e8tre <code>verbose=False</code> par <code>verbose=True</code>.</p> <p>Exercice pr\u00e9liminaire</p> <p>Dans les tests pr\u00e9sents dans la docstring de la fonction <code>tri_insertion</code>, la premi\u00e8re instruction est la suivante : <code>&gt;&gt;&gt; l = [randint(0, 99) for _ in range(10)]</code> Expliquez ce que fait cette instruction.</p> <p>Exercice 1</p> <p>\u00c9crivez la fonction <code>tri_insertion</code>. Ex\u00e9cutez le programme pour vous assurer que votre fonction soit correcte (il ne doit rien se passer).</p> <p>Exercice 2</p> <p>\u00c9crivez la fonction <code>tri_insertion_decroissant</code> permettant de trier un tableau dans l'ordre d\u00e9croissant. Que faut-il changer par rapport \u00e0 la fonction <code>tri_insertion</code> ?</p>"},{"location":"premiere/tris/tri_insertion/#cout-de-lalgorithme","title":"Co\u00fbt de l'algorithme","text":"<p>Comme pour le tri par s\u00e9lection, on analysera le co\u00fbt algorithmique du tri par insertion en comptant le nombre de comparaisons effectu\u00e9es entre deux \u00e9l\u00e9ments du tableau.</p> <p>Fichier Python</p> <ul> <li>tri_insertion_comp.py : programme Python permettant de visualiser le d\u00e9roulement du tri et le nombre de comparaisons effectu\u00e9es.</li> </ul> <p>Vous n'avez pas besoin de modifier ce fichier en dehors du contenu des deux variables globales :</p> <ul> <li><code>TABLEAU</code> : Tableau donn\u00e9 en entr\u00e9e \u00e0 la fonction effectuant le tri par insertion.</li> <li><code>MODE_SLEEP</code> : Permet d'activer le mode \"pas \u00e0 pas\". En activant ce mode, vous devrez appuyer sur la touche \"Entrer\" lorsque demand\u00e9 afin de passer \u00e0 l'\u00e9tape suivante. Affectez la variable \u00e0 <code>True</code> activer ce mode, ou \u00e0 <code>False</code> sinon.</li> </ul> <p>Exercice 1</p> <p>T\u00e9l\u00e9chargez le fichier Python ci-dessus.</p> <ol> <li>Ex\u00e9cutez ce programme avec un tableau de 5 \u00e9l\u00e9ments tri\u00e9s dans l'ordre d\u00e9croissant. Combien y a t-il de comparaisons :<ul> <li>\u00e0 la premi\u00e8re it\u00e9ration (\\(i = 1\\)) ?</li> <li>\u00e0 la deuxi\u00e8me it\u00e9ration (\\(i = 2\\)) ?</li> <li>\u00e0 la troisi\u00e8me it\u00e9ration (\\(i = 3\\)) ?</li> <li>\u00e0 la quatri\u00e8me it\u00e9ration (\\(i = 4\\)) ?</li> <li>au total ?</li> </ul> </li> <li>Faites la m\u00eame chose que pr\u00e9c\u00e9demment avec un tableau de 5 \u00e9l\u00e9ments tri\u00e9s dans l'ordre croissant.</li> <li>Selon vous, quel est le meilleur des cas et le pire des cas concernant le tableau donn\u00e9 en entr\u00e9e de la fonction de tri par insertion ?</li> </ol> <p>Rappel sur les complexit\u00e9s</p> <p>Voici un rappel sur les diff\u00e9rentes complexit\u00e9s :</p> <ul> <li>Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2, on ne rajoute qu'une seule op\u00e9ration).</li> <li>Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2, le temps d'ex\u00e9cution est multipli\u00e9 par 2).</li> <li>Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire.</li> <li>Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2, le temps d'ex\u00e9cution est multipli\u00e9 par 4).</li> <li>Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100, le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\), soit 1267650600228229401496703205376).</li> </ul> <p> Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques.(g\u00e9n\u00e9r\u00e9 avec ce programme) </p> <p>Exercice 2</p> <p>Ex\u00e9cutez le programme avec des tableaux tri\u00e9s dans l'ordre croissant de diff\u00e9rentes longueurs. Pour une longueur \\(n\\) donn\u00e9e, quel sera le nombre \\(C(n)\\) de comparaisons obtenu dans le cas o\u00f9 le tableau est tri\u00e9 dans l'ordre croissant ?</p> <p>En d\u00e9duire le co\u00fbt du tri par insertion dans le meilleur des cas (logarithmique ? lin\u00e9aire ? quasi-lin\u00e9aire ? quadratique ? exponentiel ?).</p> <p>Exercice 3</p> <p>Ex\u00e9cutez le programme avec des tableaux tri\u00e9s dans l'ordre d\u00e9croissant :</p> <ul> <li>de longueur \\(5\\),</li> <li>de longueur \\(6\\),</li> <li>de longueur \\(7\\).</li> </ul> <p>On notera le nombre de comparaisons sous la forme \\(C(n) = C_i(1) + C_i(2) + [...] + C_i(n-2) + C_i(n - 1)\\) avec \\(n\\) la longueur du tableau et \\(C_i(i)\\) le nombre de comparaisons effectu\u00e9es \u00e0 l'it\u00e9ration \\(i\\).</p> <p>Pour une longueur \\(n\\) donn\u00e9e, quel sera donc le nombre \\(C(n)\\) de comparaisons obtenu dans le cas o\u00f9 le tableau est tri\u00e9 dans l'ordre d\u00e9croissant ?</p> <p>En d\u00e9duire le co\u00fbt du tri par insertion dans le meilleur des cas (logarithmique ? lin\u00e9aire ? quasi-lin\u00e9aire ? quadratique ? exponentiel ?).</p>"},{"location":"premiere/tris/tri_insertion/#terminaison-du-tri-par-insertion","title":"Terminaison du tri par insertion","text":"<p>Pour d\u00e9montrer la terminaison de notre algorithme, il faut exhiber un variant de boucle pour chacune des boucles de l'algorithme.</p> <p>Variant de boucle</p> <p>On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que :</p> <ul> <li>\\(v\\) ne prend que des valeurs enti\u00e8res,</li> <li>\\(v\\) est initialement positive,</li> <li>\\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle.</li> </ul> <p>On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine, en un temps fini.  S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a.</p> <p>Prouver la terminaison</p> <p>Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies :</p> <ul> <li>Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT &gt; 0</li> <li>Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante.</li> </ul> <p>Si les deux propositions A et B sont vraies (\\(A \\land B\\)), l'algorithme s'arr\u00eatera toujours. Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\)), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas.</p> <p>Exemple</p> <p>D\u00e9montrons que la boucle POUR suivante se termine :</p> <pre><code>POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5:\n    Instructions ne modifiant pas la valeur de i...\n</code></pre> <p>On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE :</p> <pre><code>i = 10\nTANT QUE i &lt; 50:\n    Instructions ne modifiant pas la valeur de i...\n    i = i + 5\n</code></pre> <p>Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\), avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite.</p> <p>Ici, \\(i_0 = 10\\) et \\(r = 5\\). Donc \\(i_n = 10 + 5n\\).</p> <p>On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante :</p> <p>TANT QUE \\(i_n &lt; 50\\) TANT QUE \\(10 + 5n &lt; 50\\) TANT QUE \\(0 &lt; 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n &gt; 0\\) TANT QUE \\(40 - 5n &gt; 0\\)</p> <p>On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 40\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 40 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers, initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative).</p> <p>On a trouv\u00e9 un variant, et donc d\u00e9montr\u00e9 la terminaison de notre boucle.</p> <p>On rappelle l'algorithme du tri par insertion :</p> <p>Algorithme du tri par insertion</p> <p> ALGORITHME : tri_insertion ENTR\u00c9E : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments SORTIE : aucune (tri en place) <p>D\u00c9BUT POUR i ALLANT DE 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003\u2003cle \u2190 tableau[i] \u2003\u2003\u2003\u2003j \u2190 i \\(-\\) 1 TANT QUE j \u2265 0 ET QUE tableau[j] &gt; cle \u2003\u2003\u2003\u2003\u2003\u2003tableau[j + 1] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003j \u2190 j \\(-\\) 1 FIN TANT QUE \u2003\u2003\u2003\u2003tableau[j + 1] \u2190 cle FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME </p> <p>Exercice 1</p> <p>Montrer la terminaison de la boucle TANT QUE. Il y a deux conditions qui doivent \u00eatre v\u00e9rifi\u00e9es pour pouvoir rentrer dans la boucle. Si une seule des deux conditions (\\(j \u2265 0\\) ou \\(tableau[j] &gt; cle\\)) n'est plus v\u00e9rifi\u00e9e, alors la boucle s'arr\u00eate.</p> <p>On ne tiendra compte ici que de la premi\u00e8re condition : <code>TANT QUE j \u2265 0</code>.</p> <p>Exercice 2</p> <p>Enfin, montrer la terminaison de la boucle POUR principale de l'algorithme.</p>"},{"location":"premiere/tris/tri_insertion/#correction-du-tri-par-insertion","title":"Correction du tri par insertion","text":"<p>Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 :</p> <ul> <li>Le co\u00fbt algorithmique de l'algorithme du tri par insertion, qui est quadratique dans le pire des cas, c'est-\u00e0-dire en \\(O(n^2)\\), et qui est lin\u00e9aire dans le meilleur des cas, c'est-\u00e0-dire en \\(O(n)\\).</li> <li>La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer.</li> </ul> <p>Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct.</p> <p>On rappelle que la preuve de correction d'un algorithme permet d'affirmer :</p> <ul> <li>qu'il fournit toujours la bonne r\u00e9ponse</li> <li>sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions).</li> </ul> <p>Pour d\u00e9montrer la correction du tri par insertion, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme.</p> <p>Invariant de boucle</p> <p>On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle.</p> <p>On rappelle que l'on d\u00e9montre un invariant en utilisant un raisonnement par r\u00e9currence.</p> <p>D\u00e9monstration de l'invariant par r\u00e9currence</p> <p>Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\), avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es :</p> <ul> <li>Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\), c'est-\u00e0-dire avant le premier passage dans la boucle.</li> <li>Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle, et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\), c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus. On peut \u00e9crire \\(P_k \\implies P_{k+1}\\).</li> <li>Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e.</li> </ul> <p>Dans la cas du tri par insertion, on peut d\u00e9composer le probl\u00e8me en :</p> <ul> <li>un sous-tableau tri\u00e9 \u00e0 gauche, initialement compos\u00e9 du premier \u00e9l\u00e9ment,</li> <li>un sous-tableau non-tri\u00e9 \u00e0 droite.</li> </ul> <p>Une proposition d'invariant</p> <p>On propose l'invariant \\(P_k\\) suivant : \u00ab Apr\u00e8s \\(k\\) tours de boucle, \\(k+1\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0;k]\\) de gauche. \u00bb</p> <p>Algorithme du tri par insertion</p> <p> ALGORITHME : tri_insertion ENTR\u00c9E : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments SORTIE : aucune (tri en place) <p>D\u00c9BUT POUR i ALLANT DE 1 \u00c0 longueur(tableau) - 1 \u2003\u2003\u2003\u2003cle \u2190 tableau[i] \u2003\u2003\u2003\u2003j \u2190 i \\(-\\) 1 TANT QUE j \u2265 0 ET QUE tableau[j] &gt; cle \u2003\u2003\u2003\u2003\u2003\u2003tableau[j + 1] \u2190 tableau[j] \u2003\u2003\u2003\u2003\u2003\u2003j \u2190 j \\(-\\) 1 FIN TANT QUE \u2003\u2003\u2003\u2003tableau[j + 1] \u2190 cle FIN POUR \u2003\u2003Renvoyer \u2205 FIN ALGORITHME </p> <p>Exercice 1 : Initialisation</p> <p>Commen\u00e7ons par l'initialisation. Avant de rentrer dans la boucle (\\(k=0\\)), l'invariant \\(P_k\\) est-il v\u00e9rifi\u00e9 ?</p> R\u00e9ponse 1 <p>Avant de rentrer dans la boucle (k=0), notre sous-tableau tri\u00e9 ne contient que la premi\u00e8re valeur. Or, un sous-tableau ne contenant qu'un \u00e9l\u00e9ment est tri\u00e9.</p> <p>\\(P_k\\) correspond \u00e0 cette proposition :</p> <p>\u00ab Apr\u00e8s \\(k\\) tours de boucle, \\(k+1\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0;k]\\) de gauche. \u00bb</p> <p>\\(P_0\\) correspond donc \u00e0 :</p> <p>\u00ab Apr\u00e8s 0 tours de boucle, 1 \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau [0;0] de gauche. \u00bb</p> <p>La propri\u00e9t\u00e9 \\(P_0\\) est v\u00e9rifi\u00e9e, on a termin\u00e9 la phase d'initialisation.</p> <p>Exercice 2</p> <p>Quelle va \u00eatre la valeur :</p> <ul> <li>de \\(i\\) lors du premier tour de la boucle POUR principale ?</li> <li>de \\(j\\) avant de rentrer dans le TANT QUE lors du premier tour de la boucle principale ?</li> </ul> <p>Indiquez quelle est la relation entre \\(k\\) et \\(i\\).</p> <p>Exercice 3 : Conservation</p> <p>D\u00e9montrons maintenant la conservation, c'est-\u00e0-dire que \\(P_k \\implies P_{k+1}\\). Pour cela, on suppose d'abord vraie la proposition \\(P_k\\) : \u00ab Apr\u00e8s \\(k\\) tours de boucle, \\(k+1\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0;k]\\) de gauche. \u00bb Il faut maintenant d\u00e9montrer que la proposition \\(P_{k+1}\\) est \u00e9galement vraie.</p> <p>On distinguera pour cela trois cas :</p> <ul> <li>le cas o\u00f9 la cl\u00e9 (d'indice \\(k+1\\)) est inf\u00e9rieure \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 \\([0;k]\\),</li> <li>le cas o\u00f9 la cl\u00e9 (d'indice \\(k+1\\)) est sup\u00e9rieure \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 \\([0;k]\\),</li> <li>le cas o\u00f9 la cl\u00e9 (d'indice \\(k+1\\)) est inf\u00e9rieure \u00e0 certains \u00e9l\u00e9ments du sous-tableau tri\u00e9 \\([0;k]\\), mais pas tous.</li> </ul> R\u00e9ponse 3 <p>Au d\u00e9but du tour de boucle \\(k+1\\) :</p> <ul> <li>l'indice \\(i\\) est \u00e9gal \u00e0 \\(k+1\\),</li> <li>on dispose d'un sous-tableau \\([0;k]\\) tri\u00e9 auquel on va rajouter un nouvel \u00e9l\u00e9ment, la cl\u00e9 d'indice \\(k+1\\).</li> </ul> <p>Cas 1 : cl\u00e9 (indice \\(k+1\\)) inf\u00e9rieure aux \u00e9l\u00e9ments de [0;k] :</p> <ul> <li>La boucle TANT QUE continue jusqu'\u00e0 avoir parcouru tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9, car tous les \u00e9l\u00e9ments ont une valeur sup\u00e9rieure \u00e0 la cl\u00e9. On d\u00e9cale donc tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9 d'une case vers la droite. Les \u00e9l\u00e9ments de \\([0;k]\\) sont \u00e0 pr\u00e9sent dans \\([1;k+1]\\).</li> <li>L'ordre des \u00e9l\u00e9ments est conserv\u00e9 (on les a seulement d\u00e9cal\u00e9).</li> <li>Apr\u00e8s la derni\u00e8re it\u00e9ration, \\(j\\) vaut donc \\(-1\\), et la cl\u00e9 est replac\u00e9e en position.</li> </ul> <p>La cl\u00e9 est donc maintenant \u00e0 l'indice \\(0\\) et est inf\u00e9rieure \u00e0 tous les \u00e9l\u00e9ments du sous-tableau \\([1;k+1]\\). On peut donc affirmer que le tableau [0;k+1] est maintenant tri\u00e9 en ordre croissant.</p> <p>Donc \\(P_{k+1}\\) est VRAI.</p> <p>Cas 2 : cl\u00e9 (indice \\(k+1\\)) sup\u00e9rieure (ou \u00e9gale) aux \u00e9l\u00e9ments de \\([0;k]\\)</p> <ul> <li>On ne rentre m\u00eame pas dans le TANT QUE puisque l'une de ses conditions n'est pas v\u00e9rifi\u00e9e : <code>TANT QUE j \u2265 0 et que t[j] &gt; cle</code></li> <li>On effectue qu'une seule comparaison entre la cl\u00e9 et l'\u00e9l\u00e9ment qui le pr\u00e9c\u00e8de. \\(j\\) vaut donc \\(i-1\\) apr\u00e8s la boucle TANT QUE, et on place la cl\u00e9 avec l'instruction <code>t[j+1] \u2190 cle</code>. La cl\u00e9 reste au m\u00eame indice \\(i\\).</li> <li>Le sous-tableau \\([0, k]\\) \u00e9tait d\u00e9j\u00e0 tri\u00e9 dans l'ordre croissant, on ne le change pas.</li> <li>On rajoute la cl\u00e9 (un \u00e9l\u00e9ment plus grand ou \u00e9gal \u00e0 tous les autres) \u00e0 l'indice \\(k+1\\).</li> </ul> <p>Finalement, on obtient un sous-tableau \\([0; k+1]\\) tri\u00e9 apr\u00e8s avoir effectu\u00e9 un tour de boucle suppl\u00e9mentaire de la boucle POUR principale.</p> <p>Donc \\(P_{k+1}\\) est VRAI.</p> <p>Cas 3 : cl\u00e9 (indice \\(k+1\\)) inf\u00e9rieure \u00e0 certains \u00e9l\u00e9ments de \\([0;k]\\)</p> <p>Les \u00e9l\u00e9ments du sous-tableau \\([0;k]\\) sont tri\u00e9s, cela signifie que l'on a d'abord une premi\u00e8re partie des \u00e9l\u00e9ments inf\u00e9rieurs ou \u00e9gaux \u00e0 la cl\u00e9, puis une deuxi\u00e8me partie des \u00e9l\u00e9ments sup\u00e9rieurs \u00e0 la cl\u00e9.</p> <ul> <li>Les \u00e9l\u00e9ments d'indice \\([m;k]\\) sont sup\u00e9rieurs \u00e0 la cl\u00e9 et vont donc \u00eatre d\u00e9cal\u00e9s \u00e0 droite.</li> <li>Les \u00e9l\u00e9ments d'indice \\([0;m-1]\\) sont inf\u00e9rieurs ou \u00e9gaux \u00e0 la cl\u00e9 et ne vont donc pas bouger.</li> </ul> <p>On rappelle les conditions du TANT QUE : <code>TANT QUE j \u2265 0 et que t[j] &gt; cle</code></p> <ul> <li>La seconde condition ne sera vraie que jusqu'\u00e0 t[m] &gt; cle, on d\u00e9place donc d'une case \u00e0 droite les \u00e9l\u00e9ments [m; k] qui vont se retrouver en [m+1; k+1]. L'ordre des \u00e9l\u00e9ments n'est pas change (puisqu'on les a juste d\u00e9cal\u00e9 d'un cran vers la droite).</li> <li>Le sous-tableau [0;m-1] ne sera quant \u00e0 lui pas modifi\u00e9.</li> <li>A l'issue de la boucle, \\(j\\) contiendra \\(m-1\\). L'instruction permettant de repositionner la cl\u00e9 au bon endroit est <code>t[j+1] \u2190 cle</code>. Donc la cl\u00e9 sera plac\u00e9e \u00e0 l'indice \\(m - 1 + 1 = m\\).</li> <li>Finalement :<ul> <li>Le sous-tableau \\([0; m-1]\\) est tri\u00e9 (pas de changement) et inf\u00e9rieur ou \u00e9gal \u00e0 la cl\u00e9.</li> <li>La cl\u00e9 est \u00e0 l'indice \\(m\\).</li> <li>Le sous-tableau \\([m+1;k+1]\\) est tri\u00e9 et sup\u00e9rieur \u00e0 la cl\u00e9.</li> </ul> </li> </ul> <p>Le sous-tableau \\([0; k+1]\\) est donc bien tri\u00e9 apr\u00e8s avoir effectu\u00e9 un tour de boucle suppl\u00e9mentaire.</p> <p>Donc \\(P_{k+1}\\) est VRAI.</p> <p>Terminaison</p> <p>Il ne reste plus qu'\u00e0 v\u00e9rifier la terminaison, c'est-\u00e0-dire si l'invariant v\u00e9rifie toutes les donn\u00e9es du tableau d'entr\u00e9e.</p> <p>La boucle POUR principale va de 1 \u00e0 longueur - 1. L'algorithme aura donc, \u00e0 la fin, fait longueur - 1 tours de boucle.</p> <p>Or l'invariant \\(P_k\\) est la propri\u00e9t\u00e9 selon laquelle, \u00ab Apr\u00e8s \\(k\\) tours de boucle, \\(k+1\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0;k]\\) de gauche. \u00bb</p> <p>On avait remarqu\u00e9 la relation suivante entre \\(i\\) et \\(k\\) : \\(k = i\\).</p> <p>\u00c0 la fin de l'algorithme, \\(k\\) va donc valoir \\(longueur-1\\).</p> <p>Le nombre d'\u00e9l\u00e9ments tri\u00e9s correctement est donc \\(k + 1 = longueur-1 + 1 = longueur\\) \u00e9lements tri\u00e9s.</p> <p>Apr\u00e8s le dernier tour de boucle, le sous-tableau tri\u00e9 contient donc longueur \u00e9l\u00e9ments tri\u00e9s, c'est-\u00e0-dire tout le tableau.</p> <p>La terminaison est d\u00e9montr\u00e9e : l'algorithme agit bien sur toutes les donn\u00e9es.</p> <p>Finalement, la proposition \\(P_k\\) est bien un invariant de la boucle principale de l'algorithme du tri par insertion, et permet de prouver sa correction.</p>"},{"location":"premiere/tris/tri_selection/","title":"Le tri par s\u00e9lection","text":"<p>Le tri par s\u00e9lection (du minimum ou du maximum) est un algorithme de tri par comparaisons. Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace.</p>"},{"location":"premiere/tris/tri_selection/#presentation-du-tri","title":"Pr\u00e9sentation du tri","text":""},{"location":"premiere/tris/tri_selection/#avec-un-jeu-de-cartes","title":"Avec un jeu de cartes","text":"<p>Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel.</p> <p>On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple :</p> <p></p> <p>On ne se souciera ici que des valeurs des cartes et non de leurs couleurs. Voici l'ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte, que l'on utilisera :</p> <p></p> <p>Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.</p> <p>Principe du tri par s\u00e9lection</p> <p>Le principe du tri par s\u00e9lection du minimum est le suivant :</p> <ol> <li>Chercher l'indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier. La premi\u00e8re carte est maintenant la plus faible.</li> <li>Chercher l'indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me. Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es.</li> <li>Poursuivre ainsi jusqu\u2019\u00e0 l\u2019avant derni\u00e8re carte de la suite.</li> </ol> <p> </p> Exemple de d\u00e9roulement du tri par s\u00e9lection"},{"location":"premiere/tris/tri_selection/#simulation-avec-des-barres","title":"Simulation avec des barres","text":"<p>Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande.</p> <p>Simulation du tri par s\u00e9lection du minimum</p> <p> Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir </p>"},{"location":"premiere/tris/tri_selection/#lalgorithme","title":"L'algorithme","text":"<p>L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non.</p> <p>Tri en place</p> <p>Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure.</p> <p>Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum.</p> <p>Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes :</p> <ul> <li>l'algorithme principal <code>tri_selection(tableau)</code> permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection,</li> <li>l'algorithme <code>minimum(tableau, debut)</code> permettant la recherche de l'indice de l'\u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice <code>debut</code> donn\u00e9,</li> <li>l'algorithme <code>echanger(tableau, i, j)</code> permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices <code>i</code> et <code>j</code> donn\u00e9s.</li> </ul> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Algorithme de recherche du minimum</p> <p>ALGORITHME : minimum ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>debut</code> : l'indice \u00e0 partir duquel effectuer la recherche SORTIE : l'indice de l'\u00e9l\u00e9ment minimal dans l'intervalle <code>[debut, longueur(tableau) - 1]</code> du tableau</p> <p>D\u00c9BUT \u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME</p> <p>Algorithme d'\u00e9change d'\u00e9l\u00e9ments</p> <p>ALGORITHME : echanger ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>i</code> : l'indice d'un \u00e9l\u00e9ment du tableau <code>j</code> : l'indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Voici enfin une version en un seul algorithme :</p> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s. SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 n - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Note</p> <p>La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 <code>n - 2</code> car si tous les \u00e9l\u00e9ments de l'intervalle <code>[0, longueur(tableau) - 2]</code> sont tri\u00e9s, l'\u00e9l\u00e9ment d'indice <code>longueur(tableau) - 1</code> est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position.</p> <p>Stabilit\u00e9 du tri</p> <p>Un tri est dit stable s'il pr\u00e9serve l\u2019ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9.</p> <p>Exemple : Avec le tableau <code>[2, 4a, 4b, 3, 7, 5]</code>, l'ordre des \u00e9l\u00e9ments de valeur <code>4</code> n'est pas conserv\u00e9.</p> <p>S\u00e9lection du maximum</p> <p>Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e, puis de la partie tri\u00e9e.</p> <p>\u00c0 vous de jouer</p> <p>Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau <code>[7, 1, 5, 3, 8, 5]</code> en vous aidant du tableau suivant :</p> <p></p> <p>Question 2 : Faites de m\u00eame sur le tableau <code>[5, 3, 1, 4, 6, 2]</code>.</p> <p>Question 3 : M\u00eame chose cette fois avec le tableau <code>['b', 'e', 'c', 'w', 'p', 'q']</code>. On utilisera l'ordre lexicographique.</p> Correction <p>Question 1 :</p> <p></p> <p>Question 2 et 3 : M\u00eame principe. Pour la question 3, la comparaison se fait par ordre lexicographique (a &lt; b &lt; c &lt; d &lt; ... &lt; x &lt; y &lt; z).</p>"},{"location":"premiere/tris/tri_selection/#implementation-du-tri-par-selection","title":"Impl\u00e9mentation du tri par s\u00e9lection","text":"<p>On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python. Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type <code>list</code>).</p> <p>Question pr\u00e9liminaire</p> <p>Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python.</p> <p>Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant.</p> <p>Fichiers Python</p> <ul> <li>tri_selection.py : programme Python avec les fonctions \u00e0 compl\u00e9ter.</li> <li>tri_selection_corr.py : correction de l'impl\u00e9mentation des fonctions.</li> </ul> <p>Question 1</p> <ol> <li>Compl\u00e9ter les fonctions : <ul> <li><code>minimum(tableau, debut)</code> : renvoie l'indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle <code>[debut, len(tableau) - 1]</code>.</li> <li><code>echanger(tableau, i, j)</code> : \u00e9change les \u00e9l\u00e9ments d'indices <code>i</code> et <code>j</code> du tableau <code>tableau</code>.</li> </ul> </li> <li>Compl\u00e9ter la fonction <code>tri_selection(tableau)</code> qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau <code>tableau</code> donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes.</li> <li>Est-il n\u00e9cessaire de mettre un <code>return None</code> ? Pourquoi ?</li> <li>Peut-on dire que la fonction <code>tri_selection</code> est une proc\u00e9dure ? Pourquoi ?</li> </ol> Correction question 1 <p>1 -</p> <pre><code>def minimum(tableau: 'list[int]', debut: int) -&gt; int:\n''' Renvoie l'indice de la valeur minimale du tableau dans l'intervalle [debut, len(tableau) - 1].\n:param tableau: (list[int]) un tableau d'entiers\n:param debut: (int) l'indice \u00e0 partir duquel on recherche le minimum\n:return: (int) l'indice du minimum '''\nindice_min = debut  # Initialiser l'indice du minimum \u00e0 debut\nfor i in range(debut + 1, len(tableau)):  # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1\nif tableau[i] &lt; tableau[indice_min]:  # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_min\nindice_min = i  # Le nouvel indice du minimum est i\nreturn indice_min  # Renvoyer l'indice du minimum\ndef echanger(tableau: 'list[int]', i: int, j: int) -&gt; None:\n''' Echanger deux \u00e9l\u00e9ments d'un tableau\n    :param tableau: (list[int]) un tableau d'entiers\n    :param i: (int) l'indice d'un \u00e9l\u00e9ment du tableau\n    :param j: (int) l'indice d'un \u00e9l\u00e9ment du tableau '''\ntemp = tableau[i]\ntableau[i] = tableau[j]\ntableau[j] = temp\ndef tri_selection(tableau: 'list[int]') -&gt; None:\n''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9.\n    :param tableau: (list[int]) un tableau d'entiers \u00e0 trier '''\nn = len(tableau)  # R\u00e9cup\u00e9rer la longueur du tableau\nfor debut in range(0, n - 1):  # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*)\nindice_min = minimum(tableau, debut)  # R\u00e9cup\u00e9rer l'indice du minimum\nechanger(tableau, debut, indice_min)  # Echanger les \u00e9l\u00e9ments d'indices debut et indice_min\n</code></pre> <p>2 - Ce n'est pas n\u00e9cessaire. Lorsqu'on ne met pas de <code>return</code>, cela revient \u00e0 renvoyer <code>None</code> (c'est-\u00e0-dire rien).</p> <p>3 - La fonction <code>tri_selection</code> ne renvoie rien. Une fonction qui ne renvoie rien (et qui fonctionne donc uniquement par effets de bord) peut \u00eatre appel\u00e9e proc\u00e9dure. Attention toutefois, en Python, il n'existe pas de type 'proc\u00e9dure', il n'existe que des fonctions (type <code>function</code>).</p> <p>Tester ma fonction</p> <p>Le programme est muni de tests (lignes <code>13</code> \u00e0 <code>22</code>) ex\u00e9cut\u00e9s par le module Doctest. Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9.</p> <p>(Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.)</p> <p>Question 2</p> <p>Compl\u00e9ter la fonction <code>tri_selection_tout_en_un(tableau)</code> en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction).</p> R\u00e9ponse question 2 <pre><code>def tri_selection_tout_en_un(tableau: 'list[int]') -&gt; None:\n''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9.\n:param tableau: (list[int]) un tableau d'entiers \u00e0 trier '''\nn = len(tableau)  # R\u00e9cup\u00e9rer la longueur du tableau\nfor debut in range(0, n - 1):  # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*)\nindice_min = debut  # Initialiser l'indice du minimum \u00e0 debut\nfor i in range(debut + 1, len(tableau)):  # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1\nif tableau[i] &lt; tableau[indice_min]:  # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_min\nindice_min = i  # Le nouvel indice du minimum est i\n# On effectue une permutation\ntemp = tableau[debut]\ntableau[debut] = tableau[indice_min]\ntableau[indice_min] = temp\n</code></pre> <p>Question 3</p> <p>\u00c9crire la fonction <code>tri_selection_decroissant(tableau)</code> qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l'ordre d\u00e9croissant.</p> R\u00e9ponse question 3 <pre><code>def tri_selection_decroissant(tableau: 'list[int]') -&gt; None:\n''' Effectue le tri par s\u00e9lection dans l'ordre d\u00e9croissant des \u00e9l\u00e9ments d'un tableau donn\u00e9.\n:param tableau: (list[int]) un tableau d'entiers \u00e0 trier '''\nn = len(tableau)  # R\u00e9cup\u00e9rer la longueur du tableau\nfor debut in range(0, n - 1):  # Parcourir tous les \u00e9l\u00e9ments jusqu'\u00e0 l'avant dernier (*)\nindice_max = debut  # Initialiser l'indice du maximum \u00e0 debut\nfor i in range(debut + 1, len(tableau)):  # Parcourir tous les \u00e9l\u00e9ments du tableau \u00e0 partir de debut + 1\nif tableau[i] &gt; tableau[indice_max]:  # Si l'\u00e9l\u00e9ment d'indice i est inf\u00e9rieur \u00e0 celui d'indice indice_max\nindice_max = i  # Le nouvel indice du minimum est i\n# On effectue une permutation\ntemp = tableau[debut]\ntableau[debut] = tableau[indice_max]\ntableau[indice_max] = temp\n</code></pre> <p>Question 4</p> <p>Dans les tests, \u00e0 la ligne <code>19</code>, on trouve l'instruction <code>l = [randint(0, 100) for _ in range(20)]</code>. Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ?</p> R\u00e9ponse question 4 <p>Cette instruction cr\u00e9e une liste Python contenant 20 entiers al\u00e9atoires compris entre 0 et 100. La cr\u00e9ation est effectu\u00e9e par compr\u00e9hension.</p>"},{"location":"premiere/tris/tri_selection/#cout-du-tri-par-selection","title":"Co\u00fbt du tri par s\u00e9lection","text":"<p>Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection.  </p> <p>Le co\u00fbt d'un algorithme peut \u00eatre d\u00e9termin\u00e9 en comptant le nombre d'op\u00e9rations \u00e9l\u00e9mentaires r\u00e9alis\u00e9es. Ces op\u00e9rations peuvent \u00eatre par exemple des affectations, des tests, des op\u00e9rations arithm\u00e9tiques, des acc\u00e8s \u00e0 un \u00e9l\u00e9ment d'une liste, etc.</p> <p>Dans notre cas, on ne prendra en compte que le nombre de comparaisons entre deux \u00e9l\u00e9ments effectu\u00e9 par notre algorithme. Les comparaisons sont en l'occurence effectu\u00e9es dans l'algorithme <code>minimum</code> :</p> <pre><code>...\nSI tableau[i] &lt; tableau[indice_min], ALORS\n...\n</code></pre> <p>On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum :</p> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Algorithme de recherche du minimum</p> <p>ALGORITHME : minimum ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>debut</code> : l'indice \u00e0 partir duquel effectuer la recherche SORTIE : l'indice de l'\u00e9l\u00e9ment minimal dans l'intervalle <code>[debut, longueur(tableau) - 1]</code> du tableau</p> <p>D\u00c9BUT \u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME</p> <p>Question 1</p> <p>On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier le tableau <code>[3, 7, 1, 6, 5, 2]</code>.</p> <p>Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale <code>POUR debut ALLANT DE 0 \u00c0 n - 2</code>, c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme <code>minimum(tableau, debut)</code> pour chaque valeur de <code>debut</code> de <code>0</code> \u00e0 <code>n</code>, <code>n</code> \u00e9tant la longueur du tableau.</p> it\u00e9ration k = <code>debut</code> tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2] ... 2 1 [1, 2, 3, 6, 5, 7] ... 3 2 [1, 2, 3, 6, 5, 7] ... 4 3 [1, 2, 3, 5, 6, 7] ... 5 4 [1, 2, 3, 5, 6, 7] ... <p>Calculer le nombre de comparaisons au total, not\u00e9 \\(C(6)\\), effectu\u00e9 pour trier ce tableau.</p> R\u00e9ponse question 1 it\u00e9ration k = <code>debut</code> tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2] 5 2 1 [1, 2, 3, 6, 5, 7] 4 3 2 [1, 2, 3, 6, 5, 7] 3 4 3 [1, 2, 3, 5, 6, 7] 2 5 4 [1, 2, 3, 5, 6, 7] 1 <p>Lors de la premi\u00e8re it\u00e9ration, on effectue 5 comparaisons. Lors de la seconde it\u00e9ration, on effectue 4 comparaisons. Et ainsi de suite. Le nombre de comparaisons effectu\u00e9 au total pour un tableau de longueur \\(n = 6\\) est donc :</p> \\[ C(6) = 5 + 4 + 3 + 2 + 1 = 15 \\] <p>Pour un tableau de longueur \\(n = 7\\) par exemple, le nombre de comparaisons serait :</p> \\[ C(7) = 6 + 5 + 4 + 3 + 2 + 1 = 6 + C(6) = 21 \\] <p>Question 2</p> <p>Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ?</p> R\u00e9ponse question 2 <p>Non, le tri par s\u00e9lection effectue toujours une comparaison avec tous les \u00e9l\u00e9ments de la partie non-tri\u00e9e du tableau lors de la recherche du minimum. Le nombre de comparaisons effectu\u00e9 ne d\u00e9pend que de la longueur du tableau, et non pas des \u00e9l\u00e9ments en eux-m\u00eame.</p> <p>Question 3</p> <p>Calculer le nombre de comparaisons, not\u00e9 \\(C(n)\\), pour un tableau de taille \\(n\\). Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.)</p> <p>Calcul de la somme des termes d'une suite arithm\u00e9tique</p> <p>On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique :</p> \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] <p>Par exemple :</p> \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse question 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] <p>La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta. On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\).</p> <p>Rappel sur les complexit\u00e9s</p> <p>Voici un rappel sur les diff\u00e9rentes complexit\u00e9s :</p> <ul> <li>Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2, on ne rajoute qu'une seule op\u00e9ration).</li> <li>Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2, le temps d'ex\u00e9cution est multipli\u00e9 par 2).</li> <li>Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire.</li> <li>Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2, le temps d'ex\u00e9cution est multipli\u00e9 par 4).</li> <li>Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100, le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\), soit 1267650600228229401496703205376).</li> </ul> <p> Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques.(g\u00e9n\u00e9r\u00e9 avec ce programme) </p> <p>\u00c0 t\u00e9l\u00e9charger (facultatif)</p> <p>R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py.</p> <p>Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection, en utilisant une variable globale <code>CNT</code> incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e.</p> <p>Vous pouvez modifier l'instruction \u00e0 la ligne <code>38</code> en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons.</p>"},{"location":"premiere/tris/tri_selection/#terminaison-du-tri-par-selection","title":"Terminaison du tri par s\u00e9lection","text":"<p>Variant de boucle</p> <p>On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que :</p> <ul> <li>\\(v\\) ne prend que des valeurs enti\u00e8res,</li> <li>\\(v\\) est initialement positive,</li> <li>\\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle.</li> </ul> <p>On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine, en un temps fini.  S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a.</p> <p>Prouver la terminaison</p> <p>Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies :</p> <ul> <li>Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT &gt; 0</li> <li>Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante.</li> </ul> <p>Si les deux propositions A et B sont vraies (\\(A \\land B\\)), l'algorithme s'arr\u00eatera toujours. Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\)), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas.</p> <p>Exemple</p> <p>D\u00e9montrons que la boucle POUR suivante se termine :</p> <pre><code>POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5:\n    Instructions ne modifiant pas la valeur de i...\n</code></pre> <p>On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE :</p> <pre><code>i = 10\nTANT QUE i &lt; 50:\n    Instructions ne modifiant pas la valeur de i...\n    i = i + 5\n</code></pre> <p>Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\), avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite.</p> <p>Ici, \\(i_0 = 10\\) et \\(r = 5\\). Donc \\(i_n = 10 + 5n\\).</p> <p>On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante :</p> <p>TANT QUE \\(i_n &lt; 50\\) TANT QUE \\(10 + 5n &lt; 50\\) TANT QUE \\(0 &lt; 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n &gt; 0\\) TANT QUE \\(40 - 5n &gt; 0\\)</p> <p>On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 40\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 40 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers, initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative).</p> <p>On a trouv\u00e9 un variant, et donc d\u00e9montr\u00e9 la terminaison de notre boucle.</p> <p>Question 1</p> <p>Montrer la terminaison de l'algorithme de recherche du minimum.</p> Algorithme de recherche du minimum <p>ALGORITHME : minimum ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>debut</code> : l'indice \u00e0 partir duquel effectuer la recherche SORTIE : l'indice de l'\u00e9l\u00e9ment minimal dans l'intervalle <code>[debut, longueur(tableau) - 1]</code> du tableau</p> <p>D\u00c9BUT \u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME</p> Astuce question 1 <p>La d\u00e9marche \u00e0 suivre est similaire \u00e0 celle de l'exemple pr\u00e9c\u00e9dent.</p> <ul> <li>R\u00e9-\u00e9crire la boucle POUR sous la forme d'une boucle TANT QUE.</li> <li>Exprimer \\(i\\) en fonction du nombre de tours de boucle \\(n\\) sous la forme d'une suite enti\u00e8re arithm\u00e9tique croissante (\\(i_n = i_0 + r*n\\) o\u00f9 \\(i_0\\) est le terme initial et \\(r\\) est la raison).</li> <li>\u00c9crire la condition du TANT QUE en partant de l'in\u00e9galit\u00e9 de d\u00e9part et de l'expression de \\(i_n\\), et tenter d'obtenir une nouvelle in\u00e9galit\u00e9 de la forme \\(v_n &gt; 0\\), o\u00f9 \\(v_n\\) est une suite d'entiers strictement d\u00e9croissante.</li> <li>On a trouv\u00e9 un variant \\(v_n\\) : La boucle se termine !</li> </ul> R\u00e9ponse question 1 <p>Pour montrer la terminaison de cet algorithme, il faut prouver la terminaison de la boucle POUR.</p> <p>On r\u00e9\u00e9crit la boucle POUR sous la forme d'une boucle WHILE :</p> <p>i = debut + 1 TANT QUE i &lt; longueur(tableau): \u2003\u2003(instructions qui ne modifient pas la valeur de i) \u2003\u2003i = i + 1</p> <p>Exprimons \\(i\\) sous la forme d'une suite arithm\u00e9tique en fonction de \\(n\\), \\(n\\) \u00e9tant le nombre de tours de boucles effectu\u00e9. Avant de rentrer dans la boucle, \\(n\\) vaut \\(0\\).</p> <p>\\(i_n = i_0 + rn\\) avec \\(r\\) la raison de la suite arithm\u00e9tique, qui correspond au pas de la boucle. Apr\u00e8s chaque it\u00e9ration, on incr\u00e9mente \\(i\\) de 1, donc \\(r = 1\\).   Donc \\(i_n = debut + 1 + 1*n\\), \\(i_n = debut + 1 + n\\).</p> <p>Donc, si l'on r\u00e9\u00e9crit le TANT QUE :</p> <p>TANT QUE in &lt; longueur(tableau) TANT QUE debut + 1 + n &lt; longueur(tableau) En r\u00e9\u00e9crivant sous la forme TANT QUE VARIANT &gt; 0 : TANT QUE 0 &lt; longueur(tableau) - debut - 1 - n TANT QUE longueur(tableau) - debut - 1 - n &gt; 0</p> <p>On obtient une nouvelle suite arithm\u00e9tique, qu'on notera \\(v_n\\), telle que : \\(v_n = v_0 + rn\\) avec \\(v_0\\) = \\(longueur(tableau) - debut - 1\\) et \\(r = -1\\).</p> <p>\\(v_0\\) \u00e9tant un entier positif (car \\(longueur(tableau) - debut - 1\\) vaut toujours au minimum 1), et la raison \u00e9tant n\u00e9gative (ce qui indique que la suite est strictement d\u00e9croissante), on peut donc dire que \\(v_n\\) est bien un variant de la boucle et que notre boucle se termine.</p> <p>On a prouv\u00e9 la terminaison de la seule boucle de l'algorithme, on peut donc en conclure que <code>minimum</code> se termine.</p> <p>Question 2</p> <p>Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection.</p> Algorithme du tri par s\u00e9lection <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> Astuce question 2 <ul> <li>On a montr\u00e9 que <code>minimum</code>se termine,</li> <li>la fonction <code>echanger</code> se termine (car il s'agit simplement de trois affectations),</li> <li>il ne reste plus qu'\u00e0 montrer que la boucle principale se termine, avec la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment.</li> </ul> R\u00e9ponse question 2 <p>On a pr\u00e9c\u00e9demment montr\u00e9 que <code>minimum</code> se terminait, et l'algorithme <code>echanger</code> se termine \u00e9galement (car il s'agit simplement de trois affectations), il reste donc \u00e0 d\u00e9montrer que la boucle POUR principale de <code>tri_selection</code> se termine. Le principe est le m\u00eame que pr\u00e9c\u00e9demment.</p> <p>On r\u00e9\u00e9crit la boucle POUR sous la forme d'une boucle WHILE. ATTENTION : Il y a une variable nomm\u00e9e <code>n</code> dans l'algorithme qui correspond \u00e0 la longueur du tableau. Pour ne pas m\u00e9langer la longueur du tableau avec le nombre de tours de boucle effectu\u00e9 (que l'on note \u00e9galement \\(n\\)), on remplacera le <code>n</code> de l'algorithme par <code>longueur(tableau)</code>.</p> <p>debut = 0 TANT QUE debut &lt; longueur(tableau) - 1: \u2003\u2003(instructions qui ne modifient pas la valeur de debut) \u2003\u2003debut = debut + 1</p> <p>Exprimons \\(debut\\) sous la forme d'une suite arithm\u00e9tique en fonction de \\(n\\), \\(n\\) \u00e9tant le nombre de tours de boucles effectu\u00e9. Avant de rentrer dans la boucle, \\(n\\) vaut \\(0\\).</p> <p>\\(debut_n = debut_0 + rn\\) avec \\(r\\) la raison de la suite arithm\u00e9tique, qui correspond au pas de la boucle. Apr\u00e8s chaque it\u00e9ration, on incr\u00e9mente \\(debut\\) de 1, donc \\(r = 1\\).   Donc \\(debut_n = 0 + 1*n\\), \\(debut_n = n\\).</p> <p>Donc, si l'on r\u00e9\u00e9crit le TANT QUE :</p> <p>TANT QUE debutn &lt; longueur(tableau) - 1 TANT QUE n &lt; longueur(tableau) - 1 En r\u00e9\u00e9crivant sous la forme TANT QUE VARIANT &gt; 0 : TANT QUE longueur(tableau) - 1 - n &gt; 0</p> <p>On obtient une nouvelle suite arithm\u00e9tique, qu'on notera \\(v_n\\), telle que : \\(v_n = v_0 + rn\\) avec \\(v_0\\) = \\(longueur(tableau) - 1\\) et \\(r = -1\\).</p> <p>\\(v_0\\) \u00e9tant un entier positif (car on ne rentre dans la boucle que si \\(longueur(tableau) - 1\\) vaut au moins 1), et la raison \u00e9tant n\u00e9gative (ce qui indique que la suite est strictement d\u00e9croissante), on peut donc dire que \\(v_n\\) est bien un variant de la boucle et que notre boucle se termine.</p> <p>On a prouv\u00e9 la terminaison de notre boucle, on peut donc en d\u00e9duire que <code>tri_selection</code> se termine.</p>"},{"location":"premiere/tris/tri_selection/#preuve-de-correction-du-tri-par-selection","title":"Preuve de correction du tri par s\u00e9lection","text":"<p>Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 :</p> <ul> <li>Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique, c'est-\u00e0-dire en \\(\\Theta(n^2)\\). Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4.</li> <li>La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer.</li> </ul> <p>Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct.</p> <p>Attention</p> <p>Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct, seulement qu'il fonctionne avec un jeu de tests d\u00e9fini.</p> <p>Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests.</p> <p>La preuve de correction d'un algorithme permet d'affirmer :</p> <ul> <li>qu'il fournit toujours la bonne r\u00e9ponse</li> <li>sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions).</li> </ul> <p>Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme.</p> <p>Invariant de boucle</p> <p>On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle.</p> <p>L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu.</p> <p>Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant. Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne.</p> <p>Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence.</p> <p>D\u00e9monstration de l'invariant par r\u00e9currence</p> <p>Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\), avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es :</p> <ul> <li>Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\), c'est-\u00e0-dire avant le premier passage dans la boucle.</li> <li>Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle, et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\), c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus. On peut \u00e9crire \\(P_k \\implies P_{k+1}\\).</li> <li>Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e.</li> </ul> <p>Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en :</p> <ul> <li>un sous-tableau tri\u00e9 \u00e0 gauche,</li> <li>un sous-tableau non-tri\u00e9 \u00e0 droite.</li> </ul> <p></p> <p>\u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9.</p> <p>Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle.</p> <p>Une proposition d'invariant</p> <p>On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche. \u00bb</p> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Question 1 : Initialisation</p> <ul> <li>Apr\u00e8s 0 tour de boucle, c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ?</li> <li>La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ?</li> </ul> R\u00e9ponse 1 <p>Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche. \u00bb</p> <p>Un tableau vide est bien tri\u00e9, l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\).</p> <p>On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\), c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle.</p> <p>Question 2</p> <p>Quelle valeur va prendre <code>debut</code> lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir <code>tableau[debut]</code> apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ?</p> <p>Quelle valeur va prendre <code>debut</code> lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ?</p> <p>\u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et <code>debut</code>.</p> R\u00e9ponse 2 <p>Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, <code>debut</code> vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). <code>tableau[0]</code> contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\), on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1.</p> k <code>debut</code> nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 <p>etc.</p> <p>La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\).</p> <p>On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose :</p> <ul> <li>d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\)</li> <li>d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\)</li> </ul> <p>D\u00e9montrons maintenant la conservation.</p> <p>Question 3 : Conservation</p> <p>Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie.</p> Astuces question 3 <p>Vous pouvez proc\u00e9der comme suit :</p> <ul> <li>D\u00e9finir l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principal, notamment le nombre d'\u00e9l\u00e9ments tri\u00e9s (et l'intervalle correspondant) et le contenu de la variable <code>debut</code>.</li> <li>Supposer que la proposition \\(P_k\\) est vraie. D\u00e9tailler ce qu'il se passe lorsque l'on refait un tour de boucle.</li> <li>En d\u00e9duire l'\u00e9tat du syst\u00e8me \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle principale.</li> </ul> R\u00e9ponse 3 <p>D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale.</p> <p>\u00c0 la fin de l'it\u00e9ration \\(k\\), nous avons :</p> <ul> <li>\\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\)</li> <li>une variable <code>debut</code> contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\).</li> </ul> <p>On suppose que \\(P_k\\) est vraie, c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9.</p> <p>Si l'on refait un tour de boucle, on incr\u00e9mente <code>debut</code> (car boucle POUR). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\)</p> <p>On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l'\u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction <code>minimum</code>) \u00e0 placer \u00e0 l'indice \\(k\\).</p> <p>FINALEMENT, \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle :</p> <ul> <li>Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement).</li> <li>L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\), autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9.</li> </ul> <p>Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s.</p> <p>La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e.</p> <p>Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que :</p> <ul> <li>dans la phase d'initialisation, on a montr\u00e9 que l'invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale,</li> <li>avec la conservation, on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\), donc que l'invariant restait vrai apr\u00e8s chaque tour de boucle.</li> </ul> <p>On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que :</p> <ul> <li>\u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\), <code>debut</code> vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9,</li> <li>\u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\), <code>debut</code> vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s,</li> <li>\u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\), <code>debut</code> vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s,</li> <li>et ainsi de suite...</li> </ul> <p>DONC, \u00e0 la fin de la boucle <code>POUR debut ALLANT DE 0 \u00c0 n - 2</code>, <code>debut</code>vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\)</p> <p>Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s.</p> <p>Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s, alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9, puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9. Il est donc d\u00e9j\u00e0 \u00e0 la bonne position.</p> <p>On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection.</p>"},{"location":"premiere/tris/tri_selection/#verifier-linvariant-avec-une-assertion","title":"V\u00e9rifier l'invariant avec une assertion","text":"<p>V\u00e9rifions la validit\u00e9 de notre invariant sur la fonction <code>tri_selection</code> r\u00e9alis\u00e9e pr\u00e9c\u00e9demment en Python.</p> <p>La fonction <code>est_trie(tableau, fin)</code> renvoie <code>True</code> si les \u00e9l\u00e9ments du sous-tableau <code>[0, fin]</code> du tableau donn\u00e9 sont tri\u00e9s, <code>False</code> sinon. Si l'indice <code>fin</code> n'est pas donn\u00e9, la fonction v\u00e9rifie que l'enti\u00e8ret\u00e9 du tableau est tri\u00e9e.</p> <pre><code>def est_trie(tableau: list[int], fin: int = None) -&gt; bool:\n''' Renvoie True si les \u00e9l\u00e9ments du tableau dans [0, fin] sont tri\u00e9s, \n    False sinon. Si pas d'indice de fin donn\u00e9, v\u00e9rifier tout le tableau.\n    :param tableau: (list[int]) tableau d'entiers \u00e0 v\u00e9rifier\n    :param debut: (int) indice jusqu'auquel v\u00e9rifier les \u00e9l\u00e9ments\n    :return: (bool) True ou False selon si les \u00e9l\u00e9ments sont tri\u00e9s ou non. '''\nif fin == None: fin = len(tableau) - 1\nreturn all(tableau[i - 1] &lt;= tableau[i] for i in range(1, fin + 1))\n</code></pre> <p>Note</p> <p>La fonction native <code>all(iterable)</code> utilis\u00e9e dans la fonction ci-dessus renvoie <code>True</code> si tous les \u00e9l\u00e9ments de <code>iterable</code> sont vrais (ou s'il est vide). D\u00e8s qu'un \u00e9l\u00e9ment est faux, la fonction s'arr\u00eate et renvoie <code>False</code>.</p> <p>Question 1</p> <p>Modifier la fonction <code>tri_selection</code> en ajoutant une assertion (avec le mot-cl\u00e9 <code>assert</code>) v\u00e9rifiant, en faisant appel \u00e0 <code>est_trie</code>, qu'apr\u00e8s chaque it\u00e9ration de la boucle, la propri\u00e9t\u00e9 de l'invariant est respect\u00e9e.</p> R\u00e9ponse 1 <pre><code>def tri_selection(tableau: list[int]) -&gt; None:\n''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9.\n    :param tableau: (list[int]) un tableau d'entiers \u00e0 trier '''\nn = len(tableau)\nfor debut in range(0, n - 1):\nindice_min = minimum(tableau, debut)\nechanger(tableau, debut, indice_min)\nassert est_trie(tableau, debut)\n</code></pre> <p>\u00c0 la fin de chaque it\u00e9ration, on v\u00e9rifie avec la fonction <code>est_trie</code> que le sous-tableau <code>[0, debut]</code> est tri\u00e9.</p> <p>Dans l'interpr\u00e9teur de Thonny, ex\u00e9cuter la commande suivante : <pre><code>&gt;&gt;&gt; tri_selection([[63, 25, 81, 76, 75, 87, 66, 18, 43, 68, 48, 98, 57, 41, 97, 59, 57, 74, 28, 28]])\n</code></pre></p> <p>Question 2</p> <p>Que se passe t-il ? Pourquoi ?</p> R\u00e9ponse 2 <p>S'il ne se passe rien, c'est normal ! Cela signifie que l'expression sp\u00e9cifi\u00e9e dans l'assertion est \u00e9valu\u00e9e \u00e0 <code>True</code> \u00e0 chaque fois, et donc que l'invariant est bien v\u00e9rifi\u00e9 apr\u00e8s chaque tour de boucle.</p>"},{"location":"premiere/tris/tri_selection_correction/","title":"Le tri par s\u00e9lection","text":"<p>Le tri par s\u00e9lection (du minimum ou du maximum) est un algorithme de tri par comparaisons. Il s'agit d'un algorithme simple mais qui est, comme on le verra, inefficace.</p>"},{"location":"premiere/tris/tri_selection_correction/#presentation-du-tri","title":"Pr\u00e9sentation du tri","text":""},{"location":"premiere/tris/tri_selection_correction/#avec-un-jeu-de-cartes","title":"Avec un jeu de cartes","text":"<p>Pour comprendre le fonctionnement de ce tri, voici une petite activit\u00e9 \u00e0 r\u00e9aliser avec un jeu de cartes traditionnel.</p> <p>On souhaite trier une suite de 7 cartes arbitrairement choisies. Par exemple :</p> <p></p> <p>On ne se souciera ici que des valeurs des cartes et non de leurs couleurs. Voici l'ordre des valeurs des cartes, de la moins forte \u00e0 la plus forte, que l'on utilisera :</p> <p></p> <p>Note : Si la carte Joker existe dans votre jeu, on consid\u00e8rera qu'elle est plus forte que toutes les autres cartes.</p> <p>Principe du tri par s\u00e9lection</p> <p>Le principe du tri par s\u00e9lection du minimum est le suivant :</p> <ol> <li>Chercher l'indice de la plus faible carte de la suite (\u00e0 partir de l'indice 0) et \u00e9changer cette carte avec celle qui est plac\u00e9e en premier. La premi\u00e8re carte est maintenant la plus faible.</li> <li>Chercher l'indice de la plus faible carte de la suite en partant du 2\u00e8me \u00e9l\u00e9ment (indice 1) et \u00e9changer cette carte avec celle qui est plac\u00e9e en deuxi\u00e8me. Les deux premi\u00e8res cartes sont les plus faibles et sont maintenant tri\u00e9es.</li> <li>Poursuivre ainsi jusqu\u2019\u00e0 l\u2019avant derni\u00e8re carte de la suite.</li> </ol> <p> </p> Exemple de d\u00e9roulement du tri par s\u00e9lection"},{"location":"premiere/tris/tri_selection_correction/#simulation-avec-des-barres","title":"Simulation avec des barres","text":"<p>Voici une simulation du tri par s\u00e9lection en utilisant des barres de diff\u00e9rentes tailles comme \u00e9l\u00e9ments. Le but est de trier les barres de la plus petite \u00e0 la plus grande.</p> <p>Simulation du tri par s\u00e9lection du minimum</p> <p> Ex\u00e9cuter R\u00e9initialiser Acc\u00e9l\u00e9rer Ralentir </p>"},{"location":"premiere/tris/tri_selection_correction/#lalgorithme","title":"L'algorithme","text":"<p>L'algorithme du tri par s\u00e9lection peut \u00eatre impl\u00e9ment\u00e9 en place ou non.</p> <p>Tri en place</p> <p>Un tri est dit en place s'il modifie directement la structure qu\u2019il est en train de trier, plut\u00f4t que de cr\u00e9er et de renvoyer une nouvelle structure.</p> <p>Ici, on ne renverra pas de nouveau tableau, on modifiera directement le tableau donn\u00e9 en entr\u00e9e. Le tri s'effectuera par s\u00e9lection du minimum.</p> <p>Pour simplifier les choses, on commence par s\u00e9parer l'algorithme de tri en 3 sous-algorithmes :</p> <ul> <li>l'algorithme principal <code>tri_selection(tableau)</code> permettant de trier un tableau d'\u00e9l\u00e9ments avec le tri par s\u00e9lection,</li> <li>l'algorithme <code>minimum(tableau, debut)</code> permettant la recherche de l'indice de l'\u00e9l\u00e9ment minimal du tableau \u00e0 partir de l'indice <code>debut</code> donn\u00e9,</li> <li>l'algorithme <code>echanger(tableau, i, j)</code> permettant d'\u00e9changer deux \u00e9l\u00e9ments d'indices <code>i</code> et <code>j</code> donn\u00e9s.</li> </ul> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Algorithme de recherche du minimum</p> <p>ALGORITHME : minimum ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>debut</code> : l'indice \u00e0 partir duquel effectuer la recherche SORTIE : l'indice de l'\u00e9l\u00e9ment minimal dans l'intervalle <code>[debut, longueur(tableau) - 1]</code> du tableau</p> <p>D\u00c9BUT \u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME</p> <p>Algorithme d'\u00e9change d'\u00e9l\u00e9ments</p> <p>ALGORITHME : echanger ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>i</code> : l'indice d'un \u00e9l\u00e9ment du tableau <code>j</code> : l'indice d'un autre \u00e9l\u00e9ment du tableau SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003temp \u2190 tableau[i] \u2003\u2003tableau[i] \u2190 tableau[j] \u2003\u2003tableau[j] \u2190 temp \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Voici enfin une version en un seul algorithme :</p> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s. SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 n - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003\u2003\u2003temp \u2190 tableau[debut] \u2003\u2003\u2003\u2003tableau[debut] \u2190 tableau[indice_min] \u2003\u2003\u2003\u2003tableau[indice_min] \u2190 temp FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Note</p> <p>La premi\u00e8re boucle POUR s'arr\u00eate \u00e0 <code>n - 2</code> car si tous les \u00e9l\u00e9ments de l'intervalle <code>[0, longueur(tableau) - 2]</code> sont tri\u00e9s, l'\u00e9l\u00e9ment d'indice <code>longueur(tableau) - 1</code> est obligatoirement d\u00e9j\u00e0 \u00e0 la bonne position.</p> <p>Stabilit\u00e9 du tri</p> <p>Un tri est dit stable s'il pr\u00e9serve l\u2019ordonnancement initial des \u00e9l\u00e9ments que l'ordre consid\u00e8re comme \u00e9gaux. Le tri par s\u00e9lection est, dans le cas de notre algorithme, instable car en cas de valeurs identiques dans le tableau initial, leur ordre relatif peut \u00eatre modifi\u00e9.</p> <p>Exemple : Avec le tableau <code>[2, 4a, 4b, 3, 7, 5]</code>, l'ordre des \u00e9l\u00e9ments de valeur <code>4</code> n'est pas conserv\u00e9.</p> <p>S\u00e9lection du maximum</p> <p>Si l'on souhait \u00e9crire cet algorithme en s\u00e9lectionnant le maximum plut\u00f4t que le minimum, le principe serait le m\u00eame, mais le parcours s'effectuerait du dernier \u00e9l\u00e9ment au premier \u00e9l\u00e9ment du tableau. Le tableau serait dans ce cas d'abord compos\u00e9 de la partie non tri\u00e9e, puis de la partie tri\u00e9e.</p> <p>\u00c0 vous de jouer</p> <p>Question 1 : D\u00e9roulez le tri par s\u00e9lection du minimum sur le tableau <code>[7, 1, 5, 3, 8, 5]</code> en vous aidant du tableau suivant :</p> <p></p> <p>Question 2 : Faites de m\u00eame sur le tableau <code>[5, 3, 1, 4, 6, 2]</code>.</p> <p>Question 3 : M\u00eame chose cette fois avec le tableau <code>['b', 'e', 'c', 'w', 'p', 'q']</code>. On utilisera l'ordre lexicographique.</p>"},{"location":"premiere/tris/tri_selection_correction/#implementation-du-tri-par-selection","title":"Impl\u00e9mentation du tri par s\u00e9lection","text":"<p>On va maintenant impl\u00e9menter l'algorithme du tri par s\u00e9lection en Python. Les tableaux seront repr\u00e9sent\u00e9s par des listes Python (objets de type <code>list</code>).</p> <p>Question pr\u00e9liminaire</p> <p>Les listes Python sont-elles des structures de donn\u00e9es mutables ou non ? Citer 2 structures mutables et deux structures non-mutables en Python.</p> <p>Note : Pour simplifier, on parlera de tableaux tri\u00e9s pour parler de tableaux tri\u00e9s dans l'ordre croissant.</p> <p>\u00c0 t\u00e9l\u00e9charger</p> <p>R\u00e9cup\u00e9rer le fichier tri_selection.py \u00e0 compl\u00e9ter.</p> <p>Question 1</p> <ol> <li>Compl\u00e9ter les fonctions : <ul> <li><code>minimum(tableau, debut)</code> : renvoie l'indice de l'\u00e9l\u00e9ment de valeur minimale dans l'intervalle <code>[debut, len(tableau) - 1]</code>.</li> <li><code>echanger(tableau, i, j)</code> : \u00e9change les \u00e9l\u00e9ments d'indices <code>i</code> et <code>j</code> du tableau <code>tableau</code>.</li> </ul> </li> <li>Compl\u00e9ter la fonction <code>tri_selection(tableau)</code> qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau <code>tableau</code> donn\u00e9, en r\u00e9utilisant les deux fonctions pr\u00e9c\u00e9dentes.</li> <li>Est-il n\u00e9cessaire de mettre un <code>return None</code> ? Pourquoi ?</li> <li>Peut-on dire que la fonction <code>tri_selection</code> est une proc\u00e9dure ? Pourquoi ?</li> </ol> <p>Tester ma fonction</p> <p>Le programme est muni de tests (lignes <code>13</code> \u00e0 <code>22</code>) ex\u00e9cut\u00e9s par le module Doctest. Vous pouvez donc tester vos fonctions en ex\u00e9cutant simplement le programme. Si rien ne se passe, c'est que tout est bon. Sinon, l'interpr\u00e9teur indiquera les tests qui ont \u00e9chou\u00e9.</p> <p>(Vous pouvez rajouter d'autres tests ou effectuer des tests sur l'interpr\u00e9teur si vous le souhaitez.)</p> <p>Question 2</p> <p>Compl\u00e9ter la fonction <code>tri_selection_tout_en_un(tableau)</code> en r\u00e9-\u00e9crivant le tri par s\u00e9lection sans appeler d'autres fonctions (les recherches du minimum et les \u00e9changes sont effectu\u00e9s directement dans cette fonction).</p> <p>Question 3</p> <p>\u00c9crire la fonction <code>tri_selection_decroissant(tableau)</code> qui effectue le tri par s\u00e9lection des \u00e9l\u00e9ments d'un tableau dans l'ordre d\u00e9croissant.</p> <p>Question 4</p> <p>Dans les tests, \u00e0 la ligne <code>19</code>, on trouve l'instruction <code>l = [randint(0, 100) for _ in range(20)]</code>. Que fait cette instruction ? Quel est le nom de la m\u00e9thode de cr\u00e9ation de liste utilis\u00e9e ?</p>"},{"location":"premiere/tris/tri_selection_correction/#cout-du-tri-par-selection","title":"Co\u00fbt du tri par s\u00e9lection","text":"<p>Voyons \u00e0 pr\u00e9sent quel est le co\u00fbt du tri par s\u00e9lection. On rappelle l'algorithme du tri par s\u00e9lection et de recherche du minimum :</p> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Algorithme de recherche du minimum</p> <p>ALGORITHME : minimum ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>debut</code> : l'indice \u00e0 partir duquel effectuer la recherche SORTIE : l'indice de l'\u00e9l\u00e9ment minimal dans l'intervalle <code>[debut, longueur(tableau) - 1]</code> du tableau</p> <p>D\u00c9BUT \u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME</p> <p>Question 1</p> <p>On souhaite calculer le nombre de comparaisons effectu\u00e9 pour trier la liste <code>[3, 7, 1, 6, 5, 2]</code>.</p> <p>Compl\u00e9ter le tableau suivant en indiquant le nombre de comparaisons effectu\u00e9 apr\u00e8s chaque it\u00e9ration de la boucle principale <code>POUR debut ALLANT DE 0 \u00c0 n - 2</code>, c'est-\u00e0-dire le nombre de comparaisons effectu\u00e9 par l'algorithme <code>minimum(tableau, debut)</code> pour chaque valeur de <code>debut</code> de <code>0</code> \u00e0 <code>n</code>, <code>n</code> \u00e9tant la longueur du tableau.</p> it\u00e9ration k = <code>debut</code> tableau apr\u00e8s it\u00e9ration k nombre de comparaisons 1 0 [1, 7, 3, 6, 5, 2] ... 2 1 [1, 2, 3, 6, 5, 7] ... 3 2 [1, 2, 3, 6, 5, 7] ... 4 3 [1, 2, 3, 5, 6, 7] ... 5 4 [1, 2, 3, 5, 6, 7] ... <p>Calculer le nombre de comparaisons au total, not\u00e9 \\(C(6)\\), effectu\u00e9 pour trier ce tableau.</p> <p>Question 2</p> <p>Si l'on change les \u00e9l\u00e9ments du tableau de la question pr\u00e9c\u00e9dente, le nombre de comparaisons change t-il ? Pourquoi ?</p> <p>Question 3</p> <p>Calculer le nombre de comparaisons, not\u00e9 \\(C(n)\\), pour un tableau de taille \\(n\\). Finalement, quelle est la complexit\u00e9 du tri par s\u00e9lection ? (Voir l'aide ci-dessous si n\u00e9cessaire.)</p> <p>Calcul de la somme des termes d'une suite arithm\u00e9tique</p> <p>On rappelle la formule permettant de calculer la somme des \\(n + 1\\) premiers termes d'une suite arithm\u00e9tique :</p> \\[ S = u_0 + u_1 + ... + u_n \\] \\[ S = \\frac{n+1}{2}(u_0 + u_n) \\] \\[ S = \\frac{(1er~terme + dernier~terme) \\times (nombre~de~termes)}{2} \\] <p>Par exemple :</p> \\[ S = 1 + 2 + ... + n = \\frac{n(n+1)}{2} \\] \\[ S = \\sum_{x=0}^{n}x = \\frac{n(n+1)}{2} \\] R\u00e9ponse 3 \\[ C(n) = 1 + 2 + [...] + (n - 2) + (n - 1) = \\frac{(n - 1)n}{2} \\] \\[ C(n) = \\sum_{x=1}^{n-1}x = \\frac{(n - 1)n}{2} \\] <p>La complexit\u00e9 est donc quadratique (si l'on double la taille du tableau en entr\u00e9e, le temps d'ex\u00e9cution sera multipli\u00e9 par 4.) \u00c9tant donn\u00e9 que la complexit\u00e9 est la m\u00eame quels que soient les \u00e9l\u00e9ments du tableau fourni en entr\u00e9e, on peut utiliser la notation grand-theta. On peut \u00e9crire que la complexit\u00e9 de l'algorithme du tri par s\u00e9lection est en \\(\\Theta(n^2)\\).</p> <p>Rappel sur les complexit\u00e9s</p> <p>Voici un rappel sur les diff\u00e9rentes complexit\u00e9s :</p> <ul> <li>Logarithmique \\(\u0398(log~n)\\) : la complexit\u00e9 \u00e9volue moins vite que le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2, on ne rajoute qu'une seule op\u00e9ration).</li> <li>Lin\u00e9aire \\(\u0398(n)\\) : la complexit\u00e9 \u00e9volue comme le nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 2, le temps d'ex\u00e9cution est multipli\u00e9 par 2).</li> <li>Quasi-lin\u00e9aire \\(O(n~log~n)\\) : Interm\u00e9diaire entre lin\u00e9aire et quadratique. En pratique, un algorithme de complexit\u00e9 quasi-lin\u00e9aire a un comportement tr\u00e8s proche d\u2019un algorithme de complexit\u00e9 lin\u00e9aire.</li> <li>Quadratique \\(\u0398(n^2)\\) : la complexit\u00e9 \u00e9volue comme le carr\u00e9 du nombre n de donn\u00e9es (par exemple : si on multiplie le nombres de donn\u00e9es n par 2, le temps d'ex\u00e9cution est multipli\u00e9 par 4).</li> <li>Exponentielle \\(\u0398(2^n)\\) : la complexit\u00e9 \u00e9volue \u00e0 terme beaucoup plus vite que n'importe quelle fonction polynomiale du nombre n de donn\u00e9es (par exemple : si on multiplie le nombre de donn\u00e9es n par 100, le temps d'ex\u00e9cution est multipli\u00e9 par \\(2^{100}\\), soit 1267650600228229401496703205376).</li> </ul> <p> Courbes d'\u00e9volution des diff\u00e9rentes complexit\u00e9s algorithmiques.(g\u00e9n\u00e9r\u00e9 avec ce programme) </p> <p>\u00c0 t\u00e9l\u00e9charger</p> <p>R\u00e9cup\u00e9rer le fichier analyse_tri_selection.py.</p> <p>Ce fichier permet de compter le nombre de comparaisons effectu\u00e9 par le tri par s\u00e9lection, en utilisant une variable globale <code>CNT</code> incr\u00e9ment\u00e9e \u00e0 chaque comparaison de deux \u00e9l\u00e9ments effectu\u00e9e.</p> <p>Vous pouvez modifier l'instruction \u00e0 la ligne <code>38</code> en changeant le tableau pour lequel vous souhaitez compter le nombre de comparaisons.</p>"},{"location":"premiere/tris/tri_selection_correction/#terminaison-du-tri-par-selection","title":"Terminaison du tri par s\u00e9lection","text":"<p>Variant de boucle</p> <p>On appelle variant de boucle toute quantit\u00e9 \\(v\\) (qui peut \u00eatre d\u00e9termin\u00e9e en fonction des diff\u00e9rentes variables du programme) telle que :</p> <ul> <li>\\(v\\) ne prend que des valeurs enti\u00e8res,</li> <li>\\(v\\) est initialement positive,</li> <li>\\(v\\) d\u00e9croit strictement \u00e0 chaque passage dans la boucle.</li> </ul> <p>On exhibe un variant de boucle pour d\u00e9montrer qu'une boucle se termine, en un temps fini.  S'il existe plusieurs boucles dans un programme, il faut trouver autant de variants qu'il y en a.</p> <p>Prouver la terminaison</p> <p>Concr\u00e8tement, on peut prouver la terminaison d'un algorithme en montrant que les deux propositions suivantes sont vraies :</p> <ul> <li>Proposition A : les boucles peuvent s'exprimer sous la forme TANT QUE VARIANT &gt; 0</li> <li>Proposition B : le VARIANT est une suite d'entiers strictement d\u00e9croissante.</li> </ul> <p>Si les deux propositions A et B sont vraies (\\(A \\land B\\)), l'algorithme s'arr\u00eatera toujours. Autrement (au moins l'une des deux propositions n'est pas v\u00e9rifi\u00e9e, \\(\\neg(A \\land B)\\)), il existe au moins un cas o\u00f9 l'algorithme ne se terminera pas.</p> <p>Exemple</p> <p>D\u00e9montrons que la boucle POUR suivante se termine :</p> <pre><code>POUR i ALLANT DE 10 \u00e0 49 AVEC UN PAS DE 5:\n    Instructions ne modifiant pas la valeur de i...\n</code></pre> <p>On peut r\u00e9-\u00e9crire cette boucle POUR avec une boucle TANT QUE :</p> <pre><code>i = 10\nTANT QUE i &lt; 50:\n    Instructions ne modifiant pas la valeur de i...\n    i = i + 5\n</code></pre> <p>Si on note \\(n\\) le nombre de tours de boucle effectu\u00e9, on peut repr\u00e9senter les valeurs successives que va prendre \\(i\\) sous la forme d'une suite arithm\u00e9tique : \\(i_n = i_0 + r*n\\), avec \\(i_0\\) la valeur initiale de \\(i_n\\) et \\(r\\) la raison de la suite.</p> <p>Ici, \\(i_0 = 10\\) et \\(r = 5\\). Donc \\(i_n = 10 + 5n\\).</p> <p>On peut donc r\u00e9-\u00e9crire la condition TANT QUE de la mani\u00e8re suivante :</p> <p>TANT QUE \\(i_n &lt; 50\\) TANT QUE \\(10 + 5n &lt; 50\\) TANT QUE \\(0 &lt; 50 - 10 - 5n\\) TANT QUE \\(50 - 10 - 5n &gt; 0\\) TANT QUE \\(60 - 5n &gt; 0\\)</p> <p>On obtient donc notre variant \\(v_n\\) qui prend la forme d'une nouvelle suite arithm\u00e9tique : \\(v_n = v_0 - r*n\\) avec \\(v_0 = 60\\) pour valeur initiale et \\(r = -5\\) pour raison de la suite. Donc : \\(v_n = 60 - 5n\\) est un variant de la boucle car il s'agit d'une suite d'entiers, initialement positive et qui d\u00e9croit strictement \u00e0 chaque tour de boucle (car la raison est n\u00e9gative).</p> <p>On a trouv\u00e9 un variant, et donc d\u00e9montr\u00e9 la terminaison de notre boucle.</p> <p>Question 1</p> <p>Montrer la terminaison de l'algorithme de recherche du minimum.</p> Algorithme de recherche du minimum <p>ALGORITHME : minimum ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments <code>debut</code> : l'indice \u00e0 partir duquel effectuer la recherche SORTIE : l'indice de l'\u00e9l\u00e9ment minimal dans l'intervalle <code>[debut, longueur(tableau) - 1]</code> du tableau</p> <p>D\u00c9BUT \u2003\u2003indice_min \u2190 debut POUR i ALLANT DE debut + 1 \u00c0 longueur(tableau) - 1 SI tableau[i] &lt; tableau[indice_min], ALORS \u2003\u2003\u2003\u2003indice_min \u2190 i FIN POUR \u2003\u2003Renvoyer indice_min FIN ALGORITHME</p> Astuce question 1 <p>La d\u00e9marche \u00e0 suivre est similaire \u00e0 celle de l'exemple pr\u00e9c\u00e9dent.</p> <ul> <li>R\u00e9-\u00e9crire la boucle POUR sous la forme d'une boucle TANT QUE.</li> <li>Exprimer \\(i\\) en fonction du nombre de tours de boucle \\(n\\) sous la forme d'une suite enti\u00e8re arithm\u00e9tique croissante (\\(i_n = i_0 + r*n\\) o\u00f9 \\(i_0\\) est le terme initial et \\(r\\) est la raison).</li> <li>\u00c9crire la condition du TANT QUE en partant de l'in\u00e9galit\u00e9 de d\u00e9part et de l'expression de \\(i_n\\), et tenter d'obtenir une nouvelle in\u00e9galit\u00e9 de la forme \\(v_n &gt; 0\\), o\u00f9 \\(v_n\\) est une suite d'entiers strictement d\u00e9croissante.</li> <li>On a trouv\u00e9 un variant \\(v_n\\) : La boucle se termine !</li> </ul> <p>Question 2</p> <p>Montrer enfin la terminaison de l'algorithme du tri par s\u00e9lection.</p> Algorithme du tri par s\u00e9lection <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> Astuce question 2 <ul> <li>On a montr\u00e9 que <code>minimum</code>se termine,</li> <li>la fonction <code>echanger</code> se termine (car il s'agit simplement de trois affectations),</li> <li>il ne reste plus qu'\u00e0 montrer que la boucle principale se termine, avec la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment.</li> </ul>"},{"location":"premiere/tris/tri_selection_correction/#preuve-de-correction-du-tri-par-selection","title":"Preuve de correction du tri par s\u00e9lection","text":"<p>Dans les deux parties pr\u00e9c\u00e9dentes, nous avons montr\u00e9 :</p> <ul> <li>Le co\u00fbt algorithmique de l'algorithme du tri par s\u00e9lection, qui est toujours quadratique, c'est-\u00e0-dire en \\(\\Theta(n^2)\\). Cela signifie que si l'on double la taille de l'entr\u00e9e, le temps d'ex\u00e9cution sera \u00e0 peu pr\u00e8s multipli\u00e9 par 4.</li> <li>La terminaison de l'algorithme. On sait que l'algorithme finira toujours par se terminer.</li> </ul> <p>Il reste toutefois \u00e0 d\u00e9montrer que l'algorithme renvoie toujours un r\u00e9sultat correct.</p> <p>Attention</p> <p>Dans notre impl\u00e9mentation en Python, on a effectu\u00e9 quelques tests (avec une doctest notamment) pour v\u00e9rifier le fonctionnement de l'algorithme. Toutefois, cela ne prouve pas que l'algorithme est correct, seulement qu'il fonctionne avec un jeu de tests d\u00e9fini.</p> <p>Dans notre cas, il y a une infinit\u00e9 d'entr\u00e9es possibles qui respectent la sp\u00e9cification, on ne peut donc pas d\u00e9montrer la correction de notre algorithme en se contentant d'effectuer des tests.</p> <p>La preuve de correction d'un algorithme permet d'affirmer :</p> <ul> <li>qu'il fournit toujours la bonne r\u00e9ponse</li> <li>sur toutes les entr\u00e9es valides qu'on lui donne (les entr\u00e9es qui respectent les pr\u00e9conditions).</li> </ul> <p>Pour d\u00e9montrer la correction, il faut d\u00e9terminer un invariant de boucle pour la boucle principale de notre algorithme.</p> <p>Invariant de boucle</p> <p>On appelle invariant de boucle une propri\u00e9t\u00e9 \\(P\\) qui est vraie avant et apr\u00e8s chaque it\u00e9ration de la boucle.</p> <p>L'invariant ainsi d\u00e9termin\u00e9 permettra de prouver que le r\u00e9sultat final apr\u00e8s ex\u00e9cution est bien le r\u00e9sultat attendu.</p> <p>Il n'existe pas de m\u00e9thodologie miracle permettant de d\u00e9terminer syst\u00e9matiquement un invariant. Cela demande de chercher et de tester des choses jusqu'\u00e0 trouver une propri\u00e9t\u00e9 qui convienne.</p> <p>Une fois qu'une propri\u00e9t\u00e9 a \u00e9t\u00e9 d\u00e9termin\u00e9e, il faut la d\u00e9montrer en utilisant un raisonnement par r\u00e9currence.</p> <p>D\u00e9monstration de l'invariant par r\u00e9currence</p> <p>Pour montrer \u00e0 l'aide d'une r\u00e9currence simple qu'une proposition \\(P(k)\\) est v\u00e9rifi\u00e9e pour tout entier \\(k \\ge 0\\), avec \\(k\\) le nombre d'it\u00e9rations de la boucle effectu\u00e9es :</p> <ul> <li>Initialisation : on v\u00e9rifie que la proposition est vraie au rang initial \\(0\\), c'est-\u00e0-dire avant le premier passage dans la boucle.</li> <li>Conservation : on suppose que la proposition est vraie \u00e0 un certain rang \\(k \\ge 0\\) fix\u00e9, c'est-\u00e0-dire apr\u00e8s \\(k\\) tours de boucle, et on en d\u00e9duit qu'elle est vraie au rang suivant \\(k + 1\\), c'est-\u00e0-dire apr\u00e8s un tour de boucle en plus. On peut \u00e9crire \\(P_k \\implies P_{k+1}\\).</li> <li>Terminaison : on exploite les deux phases pr\u00e9c\u00e9dentes et on montre que la proposition est vraie sur toutes les donn\u00e9es une fois la derni\u00e8re it\u00e9ration de la boucle effectu\u00e9e.</li> </ul> <p>Dans la cas du tri par s\u00e9lection, on peut d\u00e9composer le probl\u00e8me en :</p> <ul> <li>un sous-tableau tri\u00e9 \u00e0 gauche,</li> <li>un sous-tableau non-tri\u00e9 \u00e0 droite.</li> </ul> <p></p> <p>\u00c0 chaque it\u00e9ration de la boucle principale, on s\u00e9lectionne le minimum dans le sous-tableau non-tri\u00e9 et on le place \u00e0 la fin du sous-tableau tri\u00e9.</p> <p>Initialement (avant d'entrer la premi\u00e8re fois dans la boucle), le sous-tableau tri\u00e9 est vide, et on y ajoute un \u00e9l\u00e9ment \u00e0 chaque tour de boucle.</p> <p>Une proposition d'invariant</p> <p>On propose l'invariant \\(P_k\\) suivant : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche. \u00bb</p> <p>Algorithme du tri par s\u00e9lection</p> <p>ALGORITHME : tri_selection ENTR\u00c9ES : <code>tableau</code> : un tableau d'\u00e9l\u00e9ments pouvant \u00eatre compar\u00e9s SORTIE : aucune (tri en place)</p> <p>D\u00c9BUT \u2003\u2003n \u2190 longueur(tableau) POUR debut ALLANT DE 0 \u00c0 n - 2 \u2003\u2003\u2003\u2003indice_min \u2190 minimum(tableau, debut) \u2003\u2003\u2003\u2003echanger(tableau, debut, indice_min) FIN POUR  \u2003\u2003Renvoyer \u2205 FIN ALGORITHME</p> <p>Question 1 : Initialisation</p> <ul> <li>Apr\u00e8s 0 tour de boucle, c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle, combien y a t-il d'\u00e9l\u00e9ments dans le sous-tableau tri\u00e9 ?</li> <li>La proposition \\(P_0\\) est-elle v\u00e9rifi\u00e9e ?</li> </ul> R\u00e9ponse 1 <p>Avant d'entrer une premi\u00e8re fois dans la boucle, le sous-tableau tri\u00e9 ne contient aucun \u00e9l\u00e9ment. La proposition \\(P_0\\) peut se lire : \u00ab apr\u00e8s \\(0\\) tour de boucle, \\(0\\) \u00e9l\u00e9ment est tri\u00e9 dans le sous-tableau \\([]\\) de gauche. \u00bb</p> <p>Un tableau vide est bien tri\u00e9, l'invariant est donc v\u00e9rifi\u00e9 pour \\(P_0\\).</p> <p>On a vu que l'invariant \u00e9tait bien v\u00e9rifi\u00e9 pour \\(P_0\\), c'est-\u00e0-dire avant d'entrer une premi\u00e8re fois dans la boucle.</p> <p>Question 2</p> <p>Quelle valeur va prendre <code>debut</code> lors de la premi\u00e8re it\u00e9ration de la boucle principale ? Que va contenir <code>tableau[debut]</code> apr\u00e8s la premi\u00e8re it\u00e9ration de la boucle ? Combien d'\u00e9l\u00e9ments \\(k\\) contiendra le sous-tableau tri\u00e9 apr\u00e8s cette it\u00e9ration ?</p> <p>Quelle valeur va prendre <code>debut</code> lors de la seconde it\u00e9ration de la boucle principale ? Combien d'\u00e9l\u00e9ments \\(k\\) seront ainsi tri\u00e9s apr\u00e8s cette it\u00e9ration ?</p> <p>\u00c9tablir une relation entre le nombre de tours de boucle \\(k\\) et <code>debut</code>.</p> R\u00e9ponse 2 <p>Apr\u00e8s ex\u00e9cution de la premi\u00e8re it\u00e9ration \\(k = 1\\) de la boucle principale, <code>debut</code> vaut 0 et on a \u00e9chang\u00e9 l'\u00e9l\u00e9ment minimal du tableau avec le premier \u00e9l\u00e9ment (indice 0). <code>tableau[0]</code> contient donc \u00e0 pr\u00e9sent le plus petit \u00e9l\u00e9ment du tableau. Apr\u00e8s ex\u00e9cution de la seconde it\u00e9ration \\(k = 2\\), on \u00e9change l'\u00e9l\u00e9ment minimal du sous-tableau non-tri\u00e9 avec le second \u00e9l\u00e9ment du tableau. Le nombre d'\u00e9l\u00e9ments tri\u00e9s augmente donc de 1.</p> k <code>debut</code> nombre d'\u00e9l\u00e9ments tri\u00e9s (= k) 0 0 1 0 1 2 1 2 3 2 3 <p>etc.</p> <p>La relation entre \\(k\\) et \\(debut\\) peut donc \u00eatre facilement d\u00e9finie : \\(k = debut + 1\\).</p> <p>On fait maintenant l'hypot\u00e8se que \\(P_k\\) est vraie pour un \\(k \\ge 0\\) fix\u00e9. Apr\u00e8s \\(k\\) tours de boucle, le sous-tableau tri\u00e9 contient \\(k\\) \u00e9l\u00e9ments et le tableau se compose :</p> <ul> <li>d'un sous-tableau tri\u00e9 sur \\([0, k-1]\\)</li> <li>d'un sous-tableau non-tri\u00e9 sur \\([k, longueur(tableau) - 1]\\)</li> </ul> <p>D\u00e9montrons maintenant la conservation.</p> <p>Question 3 : Conservation</p> <p>Montrer que l'implication \\(P_k \\implies P_{k+1}\\) est vraie.</p> Astuces question 3 <p>Vous pouvez proc\u00e9der comme suit :</p> <ul> <li>D\u00e9finir l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principal, notamment le nombre d'\u00e9l\u00e9ments tri\u00e9s (et l'intervalle correspondant) et le contenu de la variable <code>debut</code>.</li> <li>Supposer que la proposition \\(P_k\\) est vraie. D\u00e9tailler ce qu'il se passe lorsque l'on refait un tour de boucle.</li> <li>En d\u00e9duire l'\u00e9tat du syst\u00e8me \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle principale.</li> </ul> R\u00e9ponse 3 <p>D\u00e9finissons l'\u00e9tat du syst\u00e8me \u00e0 la fin de l'it\u00e9ration \\(k\\) de la boucle principale.</p> <p>\u00c0 la fin de l'it\u00e9ration \\(k\\), nous avons :</p> <ul> <li>\\(k\\) \u00e9l\u00e9ments tri\u00e9s dans l'intervalle \\([0, k-1]\\)</li> <li>une variable <code>debut</code> contenant \\(k-1\\) puisque, comme d\u00e9termin\u00e9 dans la question pr\u00e9c\u00e9dente, \\(k = debut + 1\\).</li> </ul> <p>On suppose que \\(P_k\\) est vraie, c'est-\u00e0-dire que le sous-tableau \\([0, k-1]\\) est tri\u00e9.</p> <p>Si l'on refait un tour de boucle, on incr\u00e9mente <code>debut</code> (car boucle POUR). \\(debut = k - 1 + 1\\) Donc : \\(debut = k\\)</p> <p>On cherche donc dans le sous-tableau non-tri\u00e9 \\([k, longueur(tableau) - 1]\\) l'\u00e9l\u00e9ment minimal (\u00e0 l'aide de la fonction <code>minimum</code>) \u00e0 placer \u00e0 l'indice \\(k\\).</p> <p>FINALEMENT, \u00e0 l'issue de l'it\u00e9ration \\(k + 1\\) de la boucle :</p> <ul> <li>Les \u00e9l\u00e9ments de \\([0, k-1]\\) sont toujours tri\u00e9s (on n'a pas effectu\u00e9 de changement).</li> <li>L'\u00e9l\u00e9ment d'indice \\(k\\) est plus grand ou \u00e9gal aux \u00e9l\u00e9ments sur \\([0, k - 1]\\), autrement, il aurait d\u00e9j\u00e0 \u00e9t\u00e9 dans le sous-tableau tri\u00e9.</li> </ul> <p>Donc, apr\u00e8s \\(k + 1\\) it\u00e9rations, les \\(k + 1\\) \u00e9l\u00e9ments du sous-tableau \\([0, k]\\) sont tri\u00e9s.</p> <p>La conservation de l'invariant apr\u00e8s chaque tour de boucle est ainsi d\u00e9montr\u00e9, et l'implication \\(P_k \\implies P_{k+1}\\) est v\u00e9rifi\u00e9e.</p> <p>Rappelons notre invariant \\(P_k\\) : \u00ab apr\u00e8s \\(k\\) tours de boucle, \\(k\\) \u00e9l\u00e9ments sont tri\u00e9s dans le sous-tableau \\([0, k-1]\\) de gauche \u00bb et que :</p> <ul> <li>dans la phase d'initialisation, on a montr\u00e9 que l'invariant \\(P_0\\) \u00e9tait vrai avant la premi\u00e8re it\u00e9ration de la boucle POUR principale,</li> <li>avec la conservation, on a montr\u00e9 que l'implication \\(P_k \\implies P_{k+1}\\), donc que l'invariant restait vrai apr\u00e8s chaque tour de boucle.</li> </ul> <p>On rappelle que la relation entre \\(k\\) et la variable de boucle \\(debut\\) est \\(k = debut + 1\\) et que :</p> <ul> <li>\u00e0 la fin de la premi\u00e8re it\u00e9ration \\(k = 1\\), <code>debut</code> vaut 0 et on a 1 \u00e9l\u00e9ment tri\u00e9,</li> <li>\u00e0 la fin de la seconde it\u00e9ration \\(k = 2\\), <code>debut</code> vaut 1 et on a 2 \u00e9l\u00e9ments tri\u00e9s,</li> <li>\u00e0 la fin de la troisi\u00e8me it\u00e9ration \\(k = 3\\), <code>debut</code> vaut 2 et on a 3 \u00e9l\u00e9ments tri\u00e9s,</li> <li>et ainsi de suite...</li> </ul> <p>DONC, \u00e0 la fin de la boucle <code>POUR debut ALLANT DE 0 \u00c0 n - 2</code>, <code>debut</code>vaut \\(n - 2\\) avec \\(n = longueur(tableau)\\) et donc : \\(k = debut + 1\\) \\(k = longueur(tableau) - 2 + 1\\) \\(k = longueur(tableau) - 1\\)</p> <p>Cela signifie qu'il y a \\(longueur(tableau) - 1\\) \u00e9l\u00e9ments tri\u00e9s, donc tous les \u00e9l\u00e9ments du tableau sauf le dernier sont tri\u00e9s.</p> <p>Or, si tous les \u00e9l\u00e9ments sur \\([0, longueur(tableau) - 2]\\) sont tri\u00e9s, alors l'\u00e9l\u00e9ment d'indice \\(longueur(tableau) - 1\\) est lui aussi tri\u00e9, puisque le dernier \u00e9l\u00e9ment est sup\u00e9rieur (ou \u00e9gal) \u00e0 tous les \u00e9l\u00e9ments du sous-tableau tri\u00e9. Il est donc d\u00e9j\u00e0 \u00e0 la bonne position.</p> <p>On a donc ainsi d\u00e9montr\u00e9 la correction de l'algorithme de tri par s\u00e9lection.</p>"},{"location":"premiere/tris/tri_selection_correction/#verifier-linvariant-avec-une-assertion","title":"V\u00e9rifier l'invariant avec une assertion","text":"<p>V\u00e9rifions la validit\u00e9 de notre invariant sur la fonction <code>tri_selection</code> r\u00e9alis\u00e9e pr\u00e9c\u00e9demment en Python.</p> <p>La fonction <code>est_trie(tableau, fin)</code> renvoie <code>True</code> si les \u00e9l\u00e9ments du sous-tableau <code>[0, fin]</code> du tableau donn\u00e9 sont tri\u00e9s, <code>False</code> sinon. Si l'indice <code>fin</code> n'est pas donn\u00e9, la fonction v\u00e9rifie que l'enti\u00e8ret\u00e9 du tableau est tri\u00e9e.</p> <pre><code>def est_trie(tableau: list[int], fin: int = None) -&gt; bool:\n''' Renvoie True si les \u00e9l\u00e9ments du tableau dans [0, fin] sont tri\u00e9s, \n    False sinon. Si pas d'indice de fin donn\u00e9, v\u00e9rifier tout le tableau.\n    :param tableau: (list[int]) tableau d'entiers \u00e0 v\u00e9rifier\n    :param debut: (int) indice jusqu'auquel v\u00e9rifier les \u00e9l\u00e9ments\n    :return: (bool) True ou False selon si les \u00e9l\u00e9ments sont tri\u00e9s ou non. '''\nif fin == None: fin = len(tableau) - 1\nreturn all(tableau[i - 1] &lt;= tableau[i] for i in range(1, fin + 1))\n</code></pre> <p>Note</p> <p>La fonction native <code>all(iterable)</code> utilis\u00e9e dans la fonction ci-dessus renvoie <code>True</code> si tous les \u00e9l\u00e9ments de <code>iterable</code> sont vrais (ou s'il est vide). D\u00e8s qu'un \u00e9l\u00e9ment est faux, la fonction s'arr\u00eate et renvoie <code>False</code>.</p> <p>Question 1</p> <p>Modifier la fonction <code>tri_selection</code> en ajoutant une assertion (avec le mot-cl\u00e9 <code>assert</code>) v\u00e9rifiant, en faisant appel \u00e0 <code>est_trie</code>, qu'apr\u00e8s chaque it\u00e9ration de la boucle, la propri\u00e9t\u00e9 de l'invariant est respect\u00e9e.</p> R\u00e9ponse 1 <pre><code>def tri_selection(tableau: list[int]) -&gt; None:\n''' Effectue le tri par s\u00e9lection en place des \u00e9l\u00e9ments d'un tableau donn\u00e9.\n    :param tableau: (list[int]) un tableau d'entiers \u00e0 trier '''\nn = len(tableau)\nfor debut in range(0, n - 1):\nindice_min = minimum(tableau, debut)\nechanger(tableau, debut, indice_min)\nassert est_trie(tableau, debut)\n</code></pre> <p>\u00c0 la fin de chaque it\u00e9ration, on v\u00e9rifie avec la fonction <code>est_trie</code> que le sous-tableau <code>[0, debut]</code> est tri\u00e9.</p> <p>Dans l'interpr\u00e9teur de Thonny, ex\u00e9cuter la commande suivante : <pre><code>&gt;&gt;&gt; tri_selection([[63, 25, 81, 76, 75, 87, 66, 18, 43, 68, 48, 98, 57, 41, 97, 59, 57, 74, 28, 28]])\n</code></pre></p> <p>Question 2</p> <p>Que se passe t-il ? Pourquoi ?</p> R\u00e9ponse 2 <p>S'il ne se passe rien, c'est normal ! Cela signifie que l'expression sp\u00e9cifi\u00e9e dans l'assertion est \u00e9valu\u00e9e \u00e0 <code>True</code> \u00e0 chaque fois, et donc que l'invariant est bien v\u00e9rifi\u00e9 apr\u00e8s chaque tour de boucle.</p>"},{"location":"terminale/arbres/","title":"Arbres : structures de donn\u00e9es et algorithmes","text":"<p>Bienvenue, ce cours se d\u00e9compose en plusieurs parties :</p> <ul> <li>COURS<ul> <li>Arbres : d\u00e9finitions et vocabulaire</li> <li>Parcours d'arbres binaires</li> <li>Type abstrait \"Arbre binaire\"</li> <li>Arbres binaires de recherche</li> </ul> </li> <li>ACTIVITES PYTHON<ul> <li>Impl\u00e9mentation des arbres binaires</li> <li>Impl\u00e9mentation des arbres binaires de recherche</li> </ul> </li> <li>EXERCICES<ul> <li>Exercices - Vocabulaire sur les arbres</li> <li>Exercices - Parcours d'un arbre binaire</li> <li>Exercices - Impl\u00e9mentations d'arbres binaires</li> <li>Exercices - Arbres binaires de recherche</li> </ul> </li> <li>EVALUATIONS<ul> <li>\u00c9valuation 1 corrig\u00e9e</li> <li>\u00c9valuation 2</li> </ul> </li> </ul> <p>Demerville Erwan</p> <p>Me contacter : demerville.erwan@gmail.com</p>"},{"location":"terminale/arbres/abr/","title":"Arbres binaires de recherche","text":"<p>Important</p> <p>Ce cours est encore en construction.</p>"},{"location":"terminale/arbres/abr/#les-arbres-binaires-de-recherche","title":"Les arbres binaires de recherche","text":""},{"location":"terminale/arbres/abr/#activite-preliminaire","title":"Activit\u00e9 pr\u00e9liminaire","text":"<p>Sources : https://www.zonensi.fr/NSI/Terminale/C05/ABR/ et Num\u00e9rique et Sciences Informatiques, 24 le\u00e7ons avec exercices corrig\u00e9s, Balabonski, Conchon, Filli\u00e2tre, Nguyen, Editions Ellipses.</p> <p>Imaginons une biblioth\u00e8que contenant un tr\u00e8s grand nombre de livres. Cette biblioth\u00e8que est organis\u00e9e de la mani\u00e8re suivante :</p> <ul> <li>Il y a 17 576 pi\u00e8ces diff\u00e9rentes.</li> <li>Chaque pi\u00e8ce est rep\u00e9r\u00e9e par une suite de trois lettres, et dans cette pi\u00e8ce sont rang\u00e9s tous les livres dont les titres commencent par ces trois lettres.</li> <li>Chaque pi\u00e8ce poss\u00e8de deux sorties, une \u00e0 droite et une \u00e0 gauche.</li> <li>La sortie de gauche m\u00e8ne toujours soit \u00e0 une salle dont les trois lettres sont situ\u00e9es avant dans l'ordre alphab\u00e9tique, soit nulle part.</li> <li>La sortie de droite m\u00e8ne toujours soit \u00e0 une salle dont les trois lettres sont situ\u00e9es apr\u00e8s dans l'ordre alphab\u00e9tique, soit nulle part.</li> </ul> <p>Une repr\u00e9sentation de cette biblioth\u00e8que peut \u00eatre donn\u00e9e sous la forme d'un arbre binaire comme celui-ci :</p> <p></p> <p>Questions</p> <ol> <li>Dans cet arbre, pr\u00e9ciser o\u00f9 sont situ\u00e9s les livres dont le titre commence par :</li> <li>KNU</li> <li>UDP</li> <li>JET</li> <li> <p>RSA</p> </li> <li> <p>Pourquoi y-a-t-il 17 576 pi\u00e8ces diff\u00e9rentes ?</p> </li> </ol> <p>Cette r\u00e9partition peut se r\u00e9v\u00e9ler incroyablement efficace.</p> <p>Dans le meilleur des cas, il ne faudra traverser qu'au maximum 15 salles pour trouver n'importe quel livre (si la biblioth\u00e8que est correctement organis\u00e9e, quasiment chaque noeud aura 2 sorties, d'o\u00f9 une hauteur d'environ \\(log_{2}{(17576)}\\), soit environ 15).</p>"},{"location":"terminale/arbres/abr/#definition-dun-arbre-binaire-de-recherche","title":"D\u00e9finition d'un arbre binaire de recherche","text":"<p>D\u00e9finition : Un arbre binaire de recherche est un arbre binaire \u00e9tiquet\u00e9 tel que :</p> <ul> <li>les \u00e9l\u00e9ments sont munis d'un ordre total (on peut les comparer),</li> <li>les \u00e9l\u00e9ments des noeuds du sous-arbre gauche sont tous \\(\\leq\\) \u00e0 l'\u00e9l\u00e9ment de la racine,</li> <li>les \u00e9l\u00e9ments des noeuds du sous-arbre droit sont tous \\(&gt;\\) \u00e0 l'\u00e9l\u00e9ment de la racine,</li> <li>les sous-arbres gauches et droit sont \u00e9galement des ABR.</li> </ul> <p></p> <p>Note : Un arbre binaire vide et une feuille sont \u00e9galement des arbres binaires de recherche.</p>"},{"location":"terminale/arbres/abr/#notion-darbre-equilibre","title":"Notion d'arbre \u00e9quilibr\u00e9","text":"<p>Une autre notion qui va nous \u00eatre utile est la notion d'arbre \u00e9quilibr\u00e9.</p> <p>D\u00e9finition : Un arbre \u00e9quilibr\u00e9 est un arbre pour lequel, pour tout n\u0153ud de l'arbre, la diff\u00e9rence entre les hauteurs de ses deux sous-arbres est au plus de 1.</p> <p></p> <ul> <li>L'arbre A est un arbre complet, et donc \u00e9quilibr\u00e9 car pour tout n\u0153ud de l'arbre, les deux sous-arbres ont au plus une diff\u00e9rence de hauteur de 1.</li> <li>L'arbre B est un arbre filiforme et donc compl\u00e8tement d\u00e9s\u00e9quilibr\u00e9. Un tel arbre s'apparente \u00e0 une liste cha\u00een\u00e9e.</li> </ul>"},{"location":"terminale/arbres/abr/#recherche-dans-un-arbre-binaire-de-recherche","title":"Recherche dans un arbre binaire de recherche","text":""},{"location":"terminale/arbres/abr/#algorithme-a-connaitre-par-cur","title":"Algorithme (\u00e0 conna\u00eetre par c\u0153ur !)","text":"<p>\u00c0 noter dans votre cours</p> <p>Voici l'algorithme r\u00e9cursif, en pseudo-code, de la recherche dans un arbre binaire de recherche.</p> <p>Recherche dans un arbre binaire de recherche</p> <pre><code>ALGO : rechercher\nENTREES : abr : Arbre binaire de recherche\n          elt : Element\nSORTIE : Bool\u00e9en\nDEBUT\n    Si abr EST VIDE, alors :\n        Renvoyer FAUX\n    Sinon si valeur_racine(abr) = elt, alors :\n        Renvoyer VRAI\n    Sinon si elt &lt;= valeur_racine(abr), alors :\n        Renvoyer rechercher(gauche(abr), elt)\n    Sinon :\n        Renvoyer rechercher(droite(abr), elt)\n</code></pre> <p>Contrairement \u00e0 la recherche dans un arbre binaire classique, on n'effectue pas la recherche dans les deux sous-arbres. En fonction de l'\u00e9l\u00e9ment recherch\u00e9, on effectue la recherche soit dans le sous-arbre gauche (si l'\u00e9l\u00e9ment est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine), soit dans le sous-arbre droit (si l'\u00e9l\u00e9ment est sup\u00e9rieur \u00e0 la valeur de la racine).</p>"},{"location":"terminale/arbres/abr/#cout-de-la-recherche","title":"Co\u00fbt de la recherche","text":"<p>Le co\u00fbt de la recherche d\u00e9pend du fait que l'arbre soit \u00e9quilibr\u00e9 ou non. Si l'on reprend les arbres pr\u00e9c\u00e9dents :</p> <p></p> <ul> <li>Dans l'arbre B, tous les noeuds sont du m\u00eame c\u00f4t\u00e9. Si l'on recherche le nombre 25 dans l'arbre (qui n'est pas pr\u00e9sent dedans), on va toujours rechercher dans le sous-arbre gauche. Si l'on note \\(n\\) le nombre de n\u0153uds de l'arbre, Le nombre d'appels r\u00e9cursifs \u00e0 <code>rechercher</code> sera de l'ordre de \\(n\\).</li> <li>Dans l'arbre A, les n\u0153uds sont r\u00e9partis \u00e0 peu pr\u00e8s \u00e9quitablement entre les sous-arbres gauches et droit. \u00c0 chaque nouvel appel r\u00e9cursif, on ne recherche que dans un des deux sous-arbres, et on peut donc \u00e9liminer \u00e0 chaque fois environ la moiti\u00e9 des n\u0153uds. Si l'on note \\(A(n)\\) le nombre d'appels \u00e0 <code>rechercher</code> en fonction de la taille \\(n\\) de l'arbre, on peut \u00e9crire \\(A(n) = 1 + A(\\frac{n}{2}) = 1 + 1 + A(\\frac{n}{4}) = [...] \\approx log_2(n)\\).</li> </ul> <p>\u00c0 noter dans votre cours</p> <p>Finalement, le co\u00fbt de la recherche dans un arbre binaire de recherche est le suivant :</p> <ul> <li>Si l'arbre est \u00e9quilibr\u00e9, le co\u00fbt de la recherche est en \\(O(log_2(n))\\),</li> <li>Si l'arbre est compl\u00e8tement d\u00e9s\u00e9quilibr\u00e9 (arbre filiforme), le co\u00fbt de la recherche est en \\(O(n)\\).</li> </ul> <p>Pour vous entra\u00eener</p> <p>Voir l'exercice 4 et sa correction pour vous entra\u00eener sur cette notion.</p>"},{"location":"terminale/arbres/abr/#insertion-dans-un-arbre-binaire-de-recherche","title":"Insertion dans un arbre binaire de recherche","text":""},{"location":"terminale/arbres/abr/#algorithme-a-connaitre-par-cur_1","title":"Algorithme (\u00e0 conna\u00eetre par c\u0153ur !)","text":"<p>\u00c0 noter dans votre cours</p> <p>Voici l'algorithme r\u00e9cursif, en pseudo-code, de l'insertion dans un arbre binaire de recherche.</p> <p>Insertion dans un arbre binaire de recherche</p> <pre><code>ALGO : insertion\nENTREES : abr : Arbre binaire de recherche\n          elt : Element\nSORTIE : Arbre binaire de recherche\nDEBUT\n    Si abr EST VIDE, alors :\n        Renvoyer nouvel_ABR(elt, ARBRE_VIDE, ARBRE_VIDE)\n    Sinon si elt &lt;= valeur_racine(abr), alors :\n        Renvoyer nouvel_ABR(valeur_racine(abr), insertion(gauche(abr)), droite(abr))\n    Sinon :\n        Renvoyer nouvel_ABR(valeur_racine(abr), gauche(abr), insertion(droite(abr)))\n</code></pre>"},{"location":"terminale/arbres/abr/#cout-de-la-recherche_1","title":"Co\u00fbt de la recherche","text":"<p>Le co\u00fbt algorithmique de l'insertion dans un arbre binaire de recherche est identique au co\u00fbt de la recherche. En effet, le principe est toujours le m\u00eame :</p> <ul> <li>Si l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer est inf\u00e9rieur ou \u00e9gal \u00e0 la racine, on ins\u00e8re l'\u00e9l\u00e9ment dans le sous-arbre gauche.</li> <li>Si l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer est sup\u00e9rieur \u00e0 la racine, on ins\u00e8re l'\u00e9l\u00e9ment dans le sous-arbre droit.</li> </ul> <p>Ainsi, si l'arbre est \u00e9quilibr\u00e9, on divise environ par deux le nombre de n\u0153uds \u00e0 chaque appel r\u00e9cursif, et le co\u00fbt est logarithmique au pire (si l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer se positionne en profondeur maximale). Dans le cas o\u00f9 l'arbre est compl\u00e8tement d\u00e9s\u00e9quilibr\u00e9 (arbre filiforme), on doit, au pire, visiter chaque n\u0153ud pour ins\u00e9rer un \u00e9l\u00e9ment, et on obtient donc un co\u00fbt lin\u00e9aire au pire, comme dans le cas d'une liste cha\u00een\u00e9e.</p> <p>\u00c0 noter dans votre cours</p> <p>Le co\u00fbt algorithmique de l'insertion dans un arbre binaire de recherche est le suivant :</p> <ul> <li>Si l'arbre est \u00e9quilibr\u00e9, le co\u00fbt de l'insertion est en \\(O(log_2(n))\\),</li> <li>Si l'arbre est compl\u00e8tement d\u00e9s\u00e9quilibr\u00e9 (arbre filiforme), le co\u00fbt de l'insertion est en \\(O(n)\\).</li> </ul> <p>Pour vous entra\u00eener</p> <p>Voir l'exercice 5 et sa correction pour vous entra\u00eener sur cette notion.</p>"},{"location":"terminale/arbres/exercices_abr/","title":"Exercices - Arbres binaires de recherche","text":"<p>Voici 3 arbres binaires :</p> <p></p> <p>Exercice 1</p> <ol> <li>Parmi ces arbres, pouvez-vous dire lesquels sont des arbres binaires de recherche ?</li> <li>Dans un arbre binaire de recherche, o\u00f9 se trouve le plus petit \u00e9l\u00e9ment ? Le plus grand \u00e9l\u00e9ment ?</li> <li>Quelle est l'ordre des noeuds lors des parcours pr\u00e9fixe, infixe, postfixe du premier arbre ?</li> <li>Quel parcours est particuli\u00e8rement int\u00e9ressant avec les arbres binaire de recherche ? Pourquoi ?</li> <li>Comment v\u00e9rifier facilement si un arbre binaire est un arbre binaire de recherche ?</li> </ol> Correction exercice 1 <ol> <li>Les trois arbres sont des arbres binaires de recherche (voir d\u00e9finition).</li> <li>Pour trouver le plus petit \u00e9l\u00e9ment d'un arbre binaire de recherche, on proc\u00e8de comme suit : Si l'arbre n'a pas de sous-arbre gauche, son minimum est alors la valeur de sa racine. Sinon, il s'agit du minimum (r\u00e9cursivement) de son sous-arbre gauche. Pour le maximum, c'est le m\u00eame principe mais avec le sous-arbre droit.</li> <li>pr\u00e9fixe : [8, 5, 3, 6, 10, 9, 12]postfixe : [3, 6, 5, 9, 12, 10, 8]infixe : [3, 5, 6, 8, 9, 10, 12]</li> <li>Les valeurs des n\u0153uds visit\u00e9s en ordre infixe sont dans l'ordre croissant.</li> <li>On peut donc facilement v\u00e9rifier qu'un arbre binaire est un arbre binaire de recherche en parcourant ses n\u0153uds dans l'ordre infixe et en v\u00e9rifiant si les valeurs de ces n\u0153uds sont tri\u00e9es dans l'ordre croissant.</li> </ol> <p>Exercice 2</p> <p>Cr\u00e9ez un arbre binaire de recherche en partant d'un arbre binaire vide et en  ins\u00e9rant progressivement les n\u0153uds de valeurs suivantes (en suivant cet ordre) : 18, 13, 21, 20, 15, 10, 23.</p> Correction exercice 2 <p>Pour dessiner cet arbre, il faut partir d'un arbre binaire vide puis ins\u00e9rer chaque valeur une par une. Pour ins\u00e9rer une valeur, il faut comparer cette valeur avec la valeur racine de l'arbre, puis ins\u00e9rer dans le sous-arbre gauche si la valeur est inf\u00e9rieur ou \u00e9gale \u00e0 la valeur racine, et \u00e0 droite sinon (en proc\u00e9dant de mani\u00e8re r\u00e9cursive). On s'arr\u00eate lorsqu'on arrive sur un arbre vide, auquel cas cet arbre vide devient une feuille contenant la valeur \u00e0 ins\u00e9rer.</p> <p>Voici l'arbre obtenu :</p> <p></p> <p>Exercice 3</p> <p>Dessinez un arbre binaire de recherche :</p> <ol> <li>En ins\u00e9rant, en suivant l'ordre, les n\u0153uds de valeurs suivantes dans l'arbre : 14,13,12,11,8,5,4,3,1 Que constatez-vous ? \u00c0 quelle autre structure de donn\u00e9es cet arbre s'apparente t-il ?</li> <li>Re-dessinez cet arbre de mani\u00e8re \u00e0 obtenir un arbre \u00e9quilibr\u00e9.</li> <li>Si on ins\u00e8re progressivement chaque valeur une par une dans l'arbre, dans quel ordre faut-il les ajouter pour obtenir un arbre \u00e9quilibr\u00e9 ? D\u00e9crivez votre m\u00e9thode.</li> </ol> Correction exercice 3 <p>\u00c0 venir...</p> <p>Exercice 4</p> <ol> <li>D\u00e9crivez, en pseudo-langage, un algorithme r\u00e9cursif de recherche dans un arbre binaire de recherche, qui renvoie <code>Vrai</code> si un \u00e9l\u00e9ment fourni en entr\u00e9e est pr\u00e9sent dans l'arbre, et <code>Faux</code> s'il ne l'est pas.</li> <li> <p>Dessinez deux arbres binaires de recherche, construits en partant d'un arbre vide et en ins\u00e9rant progressivement les n\u0153uds suivants :</p> <ul> <li>20, 15, 22, 18, 21, 16, 23, 13</li> <li>13, 15, 16, 18, 20, 21, 22, 23</li> </ul> </li> <li> <p>Que pouvez-vous dire du premier arbre ? Du second ?</p> </li> <li> <p>D\u00e9roulez votre algorithme sur les deux arbres pr\u00e9c\u00e9demment dessin\u00e9s, puis comptez le nombre d'appels r\u00e9cursifs pour rechercher :</p> <ul> <li>la valeur 17 dans le premier arbre</li> <li>la valeur 25 dans le deuxi\u00e8me arbre</li> </ul> </li> <li> <p>Choisissez ainsi le bon co\u00fbt algorithmique dans le tableau ci-dessous dans le pire cas :</p> </li> </ol> O(1) O(\\(log_2{n}\\)) O(n) O(\\(nlog_2{n}\\)) O(n\u00b2) ABR \u00e9quilibr\u00e9 ABR non \u00e9quilibr\u00e9 Correction exercice 4 <p>1 . <pre><code>ALGO : rechercher\nENTREES : abr : Arbre binaire de recherche\n          elt : Element\nSORTIE : Bool\u00e9en\nDEBUT\n    Si abr EST VIDE, alors :\n        Renvoyer FAUX\n    Sinon si valeur_racine(abr) = elt, alors :\n        Renvoyer VRAI\n    Sinon si elt &lt;= valeur_racine(abr), alors :\n        Renvoyer rechercher(gauche(abr), elt)\n    Sinon :\n        Renvoyer rechercher(droite(abr), elt)\n</code></pre></p> <p>2 . </p> <p></p> <p>3 .</p> <p>Le premier arbre est \u00e9quilibr\u00e9 (pour chaque n\u0153ud, la hauteur entre le sous-arbre gauche et droit ne diff\u00e8re pas de plus de 1.) Le deuxi\u00e8me arbre est un arbre filiforme, il n'est donc pas du tout \u00e9quilibr\u00e9 (compl\u00e8tement d\u00e9s\u00e9quilibr\u00e9).</p> <p>4 .</p> <p>Pour mieux comprendre, on notera <code>abr_20</code> pour indiquer qu'il s'agit de l'arbre de valeur racine \u00e9gale \u00e0 20, <code>abr_15</code> pour l'arbre de valeur racine \u00e9gale \u00e0 15, etc.</p> <p><pre><code>rechercher(abr_20, 16):\n    arbre NON VIDE\n    elt != valeur_racine(abr_20)\n    17 &lt; 20 donc:\n        renvoyer rechercher(abr_15, 16):\n            17 &gt; 15 donc :\n                renvoyer rechercher(abr_18, 16):\n                    17 &lt; 18 donc :\n                        renvoyer rechercher(abr_16, 16):\n                            17 &gt; 16 donc :\n                                renvoyer rechercher(abr_VIDE, 16):\n                                    arbre EST VIDE donc : \n                                        renvoyer FAUX\n</code></pre> nombre d'appels \u00e0 <code>rechercher</code>: 5</p> <p>Si l'on note \\(A(n)\\) le nombre d'appels \u00e0 <code>rechercher</code> dans le pire des cas en fonction de la taille \\(n\\) de l'arbre, on peut \u00e9crire : \\(A(0) = 1\\) (si l'arbre est vide, on compte un seul appel \u00e0 <code>rechercher</code>) \\(A(n) = 1 + A(\\frac{n}{2}) = 1 + 1 + A(\\frac{n}{4}) = [...] = \\lfloor log_2(n) \\rfloor + 2 \\approx log_2(n)\\) Exemple pour \\(n = 8\\) : \\(A(8) = log_2(8) + 2 = 3 + 2 = 5\\) appels.</p> <p>Le nombre d'appels r\u00e9cursifs correspond \u00e0 peu pr\u00e8s au nombre de fois que l'on peut diviser \\(n\\) par \\(2\\). La complexit\u00e9 est donc logarithmique.</p> <p><pre><code>rechercher(abr_13, 23):\n    arbre non vide\n    elt != valeur_racine(abr_13)\n    23 &gt; 13 donc:\n        renvoyer rechercher(abr_15, 23):\n            23 &gt; 15 donc :\n                renvoyer rechercher(abr_16, 23):\n                    23 &gt; 16 donc :\n                            renvoyer rechercher(abr_18, 23):\n                                23 &gt; 18 donc :\n                                    renvoyer rechercher(abr_20, 23):\n                                        23 &gt; 20 donc :\n                                            renvoyer rechercher(abr_21, 23):\n                                                23 &gt; 21 donc :\n                                                    renvoyer rechercher(abr_22, 23):\n                                                        23 &gt; 22 donc :\n                                                            renvoyer rechercher(abr_23, 23):\n                                                                25 &gt; 23 donc :\n                                                                rechercher(abr_VIDE, 23):\n                                                                    arbre EST VIDE donc :\n                                                                        renvoyer FAUX\n</code></pre> nombre d'appels \u00e0 <code>rechercher</code>: 9</p> <p>Si l'on note \\(A(n)\\) le nombre d'appels \u00e0 <code>rechercher</code> dans le pire des cas en fonction de la taille \\(n\\) de l'arbre, on peut \u00e9crire : \\(A(n) = n + 1 \\approx n\\).Exemple pour \\(n = 8\\) : \\(A(8) = 8 + 1 = 9\\) appels.</p> <p>Le nombre d'appels r\u00e9cursifs correspond \u00e0 peu pr\u00e8s \u00e0 la taille (nombre de noeuds) de l'arbre. La complexit\u00e9 est donc lin\u00e9aire.</p> <p>5 .</p> <p>On rappelle que la notation \\(O\\) (grand O) permet de d\u00e9finir un ordre de grandeur de la complexit\u00e9 algorithmique dans le pire des cas (on parle de borne asymptotique sup\u00e9rieure). Ici, on ne peut pas utiliser la notation \\(\\Theta\\) car le co\u00fbt d\u00e9pend de l'\u00e9l\u00e9ment recherch\u00e9 dans l'arbre, et peut donc varier pour une m\u00eame taille d'arbre.</p> O(1) O(\\(log_2{n}\\)) O(n) O(\\(nlog_2{n}\\)) O(n\u00b2) ABR \u00e9quilibr\u00e9 X ABR non \u00e9quilibr\u00e9 X <p>Exercice 5</p> <ol> <li>D\u00e9crivez, en pseudo-langage, un algorithme r\u00e9cursif d'insertion dans un arbre binaire de recherche qui renvoie un nouvel arbre dans lequel est ajout\u00e9 un n\u0153ud dont la valeur est donn\u00e9e en entr\u00e9e.</li> <li> <p>D\u00e9roulez votre algorithme sur les deux arbres dessin\u00e9s \u00e0 la question pr\u00e9c\u00e9dente, puis, pour chacun, comptez le nombre d'appels r\u00e9cursifs effectu\u00e9s pour ins\u00e9rer :</p> <ul> <li>la valeur 17 dans le premier arbre</li> <li>la valeur 25 dans le deuxi\u00e8me arbre</li> </ul> </li> <li> <p>Choisissez ainsi le bon co\u00fbt algorithmique dans le tableau ci-dessous dans le pire cas :</p> </li> </ol> O(1) O(\\(log_2{n}\\)) O(n) O(\\(nlog_2{n}\\)) O(n\u00b2) ABR \u00e9quilibr\u00e9 ABR non \u00e9quilibr\u00e9 Correction exercice 5 <p>1 . <pre><code>ALGO : insertion\nENTREES : abr : Arbre binaire de recherche\n          elt : Element\nSORTIE : Arbre binaire de recherche\nDEBUT\n    Si abr EST VIDE, alors :\n        Renvoyer nouvel_ABR(valeur_racine(abr), ARBRE_VIDE, ARBRE_VIDE)\n    Sinon si elt &lt;= valeur_racine(abr), alors :\n        Renvoyer nouvel_ABR(valeur_racine(abr), insertion(gauche(abr)), droite(abr))\n    Sinon :\n        Renvoyer nouvel_ABR(valeur_racine(abr), gauche(abr), insertion(droite(abr)))\n</code></pre></p> <p>Suite \u00e0 venir...</p>"},{"location":"terminale/arbres/exercices_parcours/","title":"Parcours d'arbres binaires","text":"<p>Info</p> <p>Ces exercices sont \u00e9galement disponibles en format PDF : fiche2_parcours.pdf</p>"},{"location":"terminale/arbres/exercices_parcours/#exercices-parcours-darbres-binaires","title":"Exercices - Parcours d'arbres binaires","text":"<p>Il existe plusieurs fa\u00e7ons de parcourir un arbre binaire (c'est-\u00e0-dire de visiter les n\u0153uds de l'arbre dans un ordre pr\u00e9cis), et notamment deux types de parcours :</p> <ul> <li>le parcours en largeur d'abord,</li> <li>le parcours en profondeur d'abord.</li> </ul>"},{"location":"terminale/arbres/exercices_parcours/#parcours-en-profondeur","title":"Parcours en profondeur","text":"<p>En l\u2019occurrence, trois cas particuliers du parcours en profondeur sont \u00e0 conna\u00eetre sur les arbres binaires : le parcours en ordre pr\u00e9fixe, en ordre infixe et en ordre suffixe (ou postfixe).</p> <p>Ces parcours se d\u00e9finissent de mani\u00e8re r\u00e9cursive. Ils consistent \u00e0 traiter la racine de l'arbre et \u00e0 parcourir r\u00e9cursivement les sous-arbres gauche et droit de la racine. Les parcours pr\u00e9fixe, infixe et suffixe se distinguent par l'ordre dans lequel sont effectu\u00e9s ces traitements.</p>"},{"location":"terminale/arbres/exercices_parcours/#parcours-prefixe-infixe-postfixe","title":"Parcours pr\u00e9fixe, infixe, postfixe","text":"<p>Voici un arbre binaire :</p> <p> </p> Un arbre binaire <p>D\u00e9roulement parcours pr\u00e9fixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours pr\u00e9fixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On <code>visite</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol> <p>Exercice 1</p> <p>En suivant le d\u00e9roulement pr\u00e9c\u00e9dent, listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s dans l'ordre pr\u00e9fixe.</p> <p>D\u00e9roulement parcours suffixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours suffixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours suffixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours suffixe</code> du sous-arbre droit (s'il est NON vide).</li> <li>On <code>visite</code> le n\u0153ud racine de l'arbre.</li> </ol> <p>Exercice 2</p> <p>En suivant le d\u00e9roulement pr\u00e9c\u00e9dent, listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s dans l'ordre suffixe.</p> <p>D\u00e9roulement parcours infixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours infixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours infixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On <code>visite</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours infixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol> <p>Exercice 3</p> <p>En suivant le d\u00e9roulement pr\u00e9c\u00e9dent, listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s dans l'ordre infixe.</p> <p>Exercice 4</p> <ol> <li>Redessinez l'arbre en figure 1 en y ajoutant les n\u0153uds vides (not\u00e9s \\(\\emptyset\\)) et les ar\u00eates associ\u00e9es. Vous pouvez les dessiner en pointill\u00e9s.</li> <li>Tracez le contour de l'arbre (en commen\u00e7ant \u00e0 gauche de la racine).</li> <li>Listez les n\u0153uds de l'arbre de trois mani\u00e8re diff\u00e9rentes :<ul> <li>Une premi\u00e8re liste dans laquelle vous ajoutez chaque n\u0153ud lorsque vous passez \u00e0 sa gauche. Quel est l'ordre de parcours (pr\u00e9fixe, infixe, postfixe) ainsi obtenu ?</li> <li>Une seconde liste dans laquelle vous ajoutez chaque n\u0153ud lorsque vous passez \u00e0 sa droite. Quel est l'ordre de parcours (pr\u00e9fixe, infixe, postfixe) ainsi obtenu ?</li> <li>Une troisi\u00e8me liste dans laquelle vous ajoutez chaque n\u0153ud lorsque vous passez en dessous. Quel est l'ordre de parcours (pr\u00e9fixe, infixe, postfixe) ainsi obtenu ?</li> </ul> </li> </ol>"},{"location":"terminale/arbres/exercices_parcours/#parcours-en-largeur","title":"Parcours en largeur","text":"<p>Le parcours en largeur consiste \u00e0 parcourir un arbre niveau par niveau. Le n\u0153ud de profondeur 0 (ou 1 selon la convention choisie) est d'abord parcouru, puis les n\u0153uds de profondeur 1 (ou 2), et ainsi de suite.  \u00c0 chaque niveau, les n\u0153uds sont parcourus de la gauche vers la droite.</p> <p>D\u00e9roulement parcours en largeur</p> <p>Le parcours en largeur fonctionne donc de la mani\u00e8re suivante :</p> <ul> <li>On <code>visite</code> le n\u0153ud racine</li> <li>On <code>visite</code> les n\u0153uds fils du n\u0153ud racine (d'abord le fils gauche, puis le fils droit)</li> <li>Puis on <code>visite</code> les n\u0153uds fils du fils gauche du n\u0153ud racine, puis les n\u0153uds fils du fils droit du n\u0153ud racine</li> <li>Et ainsi de suite...</li> </ul> <p>Par exemple, si l'on parcourt l'arbre suivant en largeur, les n\u0153uds seront visit\u00e9s dans cet ordre : <code>[E, B, G, A, D, F, H, C]</code></p> <p></p> <p>Exercice 5</p> <p>Listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s lors d'un parcours en largeur.</p> <p>Exercice 6</p> <p>Si l'on impl\u00e9mentait l'algorithme de parcours en largeur, on aurait besoin d'une structure de donn\u00e9es permettant d'y stocker \u00e0 chaque fois les prochains n\u0153uds \u00e0 visiter (qui contiendrait initialement la racine de l'arbre), de mani\u00e8re \u00e0 ce que le premier n\u0153ud ajout\u00e9 soit le premier n\u0153ud visit\u00e9.</p> <p>\u00c0 votre avis, quelle structure de donn\u00e9es lin\u00e9aire pourrait-on utiliser pour impl\u00e9menter le parcours en largeur ?</p>"},{"location":"terminale/arbres/exercices_vocabulaire/","title":"Vocabulaire sur les arbres","text":"<p>Info</p> <p>Ces exercices sont \u00e9galement disponibles en format PDF : fiche1_vocabulaire.pdf</p>"},{"location":"terminale/arbres/exercices_vocabulaire/#exercices-vocabulaire-sur-les-arbres","title":"Exercices - Vocabulaire sur les arbres","text":""},{"location":"terminale/arbres/exercices_vocabulaire/#dessiner-un-arbre","title":"Dessiner un arbre","text":""},{"location":"terminale/arbres/exercices_vocabulaire/#une-arborescence-de-fichiers","title":"Une arborescence de fichiers","text":"<p>Sur Linux, on peut lister r\u00e9cursivement les r\u00e9pertoires et fichiers du syst\u00e8me \u00e0 l'aide de la commande <code>tree</code>. Voici un exemple d'arborescence obtenue apr\u00e8s ex\u00e9cution de cette commande :</p> <p> </p> Une arborescence sur Linux <p>Exercice 1</p> <p>Dessinez un arbre repr\u00e9sentant cette arborescence, en partant de l'arbre suivant :</p> <p></p> <ol> <li>Quelle est la taille de cet arbre ?</li> <li>Combien y a t-il d'ar\u00eates dans l'arbre ?</li> <li>Quelles sont les feuilles de l'arbre ?</li> </ol> <p>En consid\u00e9rant que la profondeur de la racine est de 1 :</p> <ol> <li>Quelle est la profondeur du n\u0153ud D5 ?</li> <li>Quelle est la hauteur de l'arbre ?</li> <li>Cet arbre est-il un arbre binaire ? Pourquoi ?</li> </ol> Correction exercice 1 <ol> <li>La taille est de 11, car il y a 11 noeuds dans l'arbre.</li> <li>En sachant que chaque noeud, \u00e0 l'exception du noeud racine, poss\u00e8de exactement une ar\u00eate le reliant \u00e0 son noeud p\u00e8re, le nombre d'ar\u00eates d'un arbre est toujours \\(taille - 1\\). Ici, le nombre d'ar\u00eates est donc de 11 - 1 = 10.</li> <li>Une feuille est un noeud qui n'a pas de noeuds fils. Ici, les feuilles sont au nombre de 5 : F2.txt, F6, F1.txt, D5, F3.txt.</li> <li>La profondeur du noeud D5, en consid\u00e9rant que la racine a une profondeur de 1, est le nombre de noeuds qui le s\u00e9pare de la racine : Elle est donc ici de 3.</li> <li>La hauteur d'un arbre est la plus grande profondeur des feuilles de l'arbre, ici elle est donc de 4.</li> <li>Dans un arbre binaire, un noeud ne peut avoir qu'un, deux ou trois noeuds fils. Ici, ce n'est pas le cas, l'arbre n'est donc pas un arbre binaire (on dira que c'est un arbre enracin\u00e9).</li> </ol>"},{"location":"terminale/arbres/exercices_vocabulaire/#arbre-dune-page-html","title":"Arbre d'une page HTML","text":"<p>Voici le code HTML d'une page web :</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;title&gt;Ma superbe page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Mon super titre&lt;/h1&gt;\n&lt;p&gt;Mon super paragraphe&lt;/p&gt;\n&lt;img src=\"mon_image.png\" alt=\"ma superbe image\" /&gt;\n&lt;/body&gt;\n&lt;footer&gt;\n&lt;p&gt;Un pied de page&lt;/p&gt;\n&lt;/footer&gt;\n&lt;/html&gt;\n</code></pre> <p>L'arbre (appel\u00e9 arbre DOM) repr\u00e9sentant ce code HTML est le suivant :</p> <p> </p> Arbre DOM d'une page HTML <p>Exercice 2</p> <p>\u00c0 votre tour, dessinez l'arbre DOM repr\u00e9sentant la page HTML suivante :</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;link href=\"main.css\" rel=\"stylesheet\"&gt;\n&lt;title&gt;Pok\u00e9mons&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;section&gt;\n&lt;h1&gt;Types des pok\u00e9mons&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;FEU&lt;/li&gt;\n&lt;li&gt;FOUDRE&lt;/li&gt;\n&lt;li&gt;EAU&lt;/li&gt;\n&lt;li&gt;HERBE&lt;/li&gt;\n&lt;li&gt;NORMAL&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ol> <li>Quelle est la taille de l'arbre obtenu ?</li> <li>Quelle est la hauteur de l'arbre obtenu :</li> <li>Si la profondeur de la racine est de 0 ?</li> <li>Si la profondeur de la racine est de 1 ?</li> <li>Quels types d'\u00e9l\u00e9ments repr\u00e9sentent les feuilles de l'arbre ?</li> <li>Si les n\u0153uds de l'arbre \u00e9taient des instances d'une classe <code>Noeud</code> caract\u00e9ris\u00e9s par une \u00e9tiquette (<code>html</code>, <code>body</code>, etc) et des donn\u00e9es, quelles pourraient \u00eatre ces donn\u00e9es ? (voir la balise <code>meta</code> ou <code>link</code> du code ci-dessus.)</li> </ol> Correction exercice 2 <p>Voici l'arbre obtenu \u00e0 partir de ce code HTML : </p> <ol> <li>La taille est de 21 car il y a 21 noeuds* dans l'arbre.</li> <li>La hauteur est la profondeur des feuilles les plus \u00e9loign\u00e9es de la racine, elle est de 5 si la profondeur de la racine vaut 0, et de 6 si la profondeur de la racine vaut 1.</li> <li>Les feuilles de l'arbre repr\u00e9sentent :<ul> <li>le texte brut contenu \u00e0 l'int\u00e9rieur des balises ouvrantes et fermantes,</li> <li>Les balises autofermantes (comme la balise <code>meta</code>, <code>link</code>, etc.)</li> </ul> </li> <li>Pour repr\u00e9senter correctement une page web, on aurait besoin d'un objet permettant de stocker les attributs associ\u00e9s aux balises. Par exemple ici, les attributs de la balise <code>link</code> sont <code>href</code> (qui vaut <code>main.css</code>, un fichier CSS) et <code>rel</code> (qui vaut <code>stylesheet</code>, indiquant que la ressource est une feuille de style CSS). En Python, on pourrait imaginer par exemple de stocker ces attributs dans un dictionnaire.</li> </ol>"},{"location":"terminale/arbres/exercices_vocabulaire/#arbre-dune-expression-arithmetique","title":"Arbre d'une expression arithm\u00e9tique","text":"<p>Voici un arbre binaire repr\u00e9sentant l'expression arithm\u00e9tique \\((6 + 9) / 3\\) :</p> <p> </p> Arbre d'une expression arithm\u00e9tique <p>Exercice 3</p> <p>\u00c0 votre tour, dessinez l'arbre binaire correspondant \u00e0 l'expression \\(\\frac{5*8}{30-(8*3)}\\).</p> <ol> <li>Pour quels op\u00e9rateurs le positionnement (gauche, droit) des op\u00e9randes a une importance ? Pourquoi ?</li> <li>Quelle est la taille de l'arbre obtenu ?</li> <li>Quelles sont les feuilles de l'arbre ? Quelle remarque pouvez-vous faire ?</li> </ol> <p> En consid\u00e9rant que la profondeur de la racine est de 0 :</p> <ol> <li>Quelle est la profondeur des feuilles les moins \u00e9loign\u00e9es de la racine ?</li> <li>Quelle est la hauteur de l'arbre ?</li> </ol> Correction exercice 3 <p>Voici l'arbre obtenu : </p> <ol> <li>Il a une importance pour la soustraction et la division. On n'obtient par exemple pas le m\u00eame r\u00e9sultat en faisant \\(30 - 24\\) et \\(24 - 30\\). Ici, on a en effet d\u00e9cid\u00e9 que le sous-arbre gauche repr\u00e9sentait l'op\u00e9rande gauche, et le sous-arbre droit l'op\u00e9rande droite.</li> <li>L'arbre obtenu est de taille 9 (car il y a 9 noeuds).</li> <li>Les feuilles de cet arbre sont <code>5</code>, <code>8</code>, <code>30</code>, <code>8</code> et <code>3</code>. Toutes les feuilles de l'arbre contiennent les valeurs num\u00e9riques, tandis que les autres noeuds contiennent les op\u00e9rateurs.</li> <li>Les feuilles de l'arbre les moins \u00e9loign\u00e9es de la racine sont de profondeur 2 (en prenant 0 comme profondeur pour la racine.)</li> <li>La hauteur de cet arbre est de 3.</li> </ol>"},{"location":"terminale/arbres/exercices_vocabulaire/#encadrement-de-la-hauteur","title":"Encadrement de la hauteur","text":"<p>Pour l'exercice suivant, on consid\u00e9rera que la profondeur de la racine d'un arbre est de 1. Voici deux arbres binaires :</p> <p> </p> Deux arbres binaires <p>Exercice 4</p> <ol> <li>Parmi ces deux arbres, lequel est un arbre filiforme ? Un arbre complet ?</li> <li>\u00c0 quelle autre structure de donn\u00e9es s'apparente un arbre filiforme ? Pourquoi ?</li> <li>Quelle est la taille de ces deux arbres ?</li> <li>Quelles sont toutes les hauteurs possibles pour une taille \\(n = 5\\) ?</li> <li>\u00c9tablissez une relation entre la taille d'un arbre not\u00e9e \\(n\\) et la hauteur de cet arbre not\u00e9e \\(h\\), dans le cas o\u00f9 l'arbre est filiforme.</li> <li> <ol> <li>Compl\u00e9tez l'arbre B de mani\u00e8re \u00e0 obtenir un arbre parfait.</li> <li>Combien y a t-il de n\u0153uds de profondeur 1, 2 et 3  dans cet arbre parfait ? En d\u00e9duire combien il y aurait de noeuds de profondeur 4 et 5 dans un arbre parfait de hauteur 5 (vous pouvez dessiner un tableau).</li> <li>\u00c9tablissez une relation entre le nombre de n\u0153uds \u00e0 une certaine profondeur, not\u00e9 \\(n_{p}\\), en fonction de cette profondeur, not\u00e9e \\(p\\).</li> <li>En d\u00e9duire une expression calculant la taille \\(n\\) (nombre de n\u0153uds) d'un arbre parfait en fonction de sa hauteur \\(h\\).</li> </ol> </li> <li>Enfin, proposez d'abord un encadrement de la taille d'un arbre binaire not\u00e9e \\(n\\) en fonction de la hauteur not\u00e9e \\(h\\) (en utilisant vos r\u00e9ponses aux questions <code>5.</code> et <code>6.d.</code>). \u00c0 partir de l'encadrement pr\u00e9c\u00e9dent, d\u00e9duire un encadrement de la hauteur d'un arbre binaire en fonction de sa taille.</li> </ol> Correction exercice 4 <ol> <li>L'arbre A est un arbre filiforme. L'arbre B est un arbre complet.</li> <li>Un arbre filiforme s'apparente \u00e0 une liste cha\u00een\u00e9e. En effet, chaque noeud pointe vers un seul autre noeud de l'arbre. On verra dans le cours sur les arbres binaires de recherche que la recherche et l'insertion dans un arbre filiforme n'est pas int\u00e9ressante (car m\u00eame co\u00fbt que sur une liste cha\u00een\u00e9e).</li> <li>Ces deux arbres sont de taille \\(n = 5\\).</li> <li>Un arbre de taille 5 peut \u00eatre de hauteur minimale 3 (arbre B) et de hauteur maximale 5 (arbre A) avec une profondeur 1 pour le noeud racine. Les diff\u00e9rentes hauteurs possibles sont donc 3, 4 et 5.</li> <li>Dans le cas o\u00f9 l'arbre est filiforme, la hauteur d'un arbre est \u00e9gale \u00e0 son nombre de noeuds (= sa taille). On peut donc \u00e9crire que \\(n = h\\).</li> <li> <p>a. Voici l'arbre obtenu (il suffit d'ajouter deux noeuds dans le niveau le plus bas de l'arbre pour que celui-ci soit rempli et que l'arbre devienne un arbre parfait) :  b. En notant \\(p\\) la profondeur et \\(n_{p}\\) le nombre de noeuds de profondeur \\(p\\) :  c. Du tableau pr\u00e9c\u00e9dent, on peut d\u00e9duire la relation \\(n_{p} = 2^{p-1}\\). d. Finalement, la taille not\u00e9e \\(n\\) d'un arbre parfait en fonction de sa hauteur not\u00e9e \\(h\\) peut se calculer de la mani\u00e8re suivante : \\(n = 2^{0} + 2^{1} + [...] + 2^{h-1} = 2^{h} - 1\\)</p> </li> <li> <p>On a pr\u00e9c\u00e9demment d\u00e9termin\u00e9 la taille minimale d'un arbre binaire en fonction de sa hauteur : \\(n_{min} = h\\) (cas de l'arbre filiforme) On a \u00e9galement determin\u00e9 la taille maximale d'un arbre binaire en fonction de sa hauteur : \\(n_{max} = 2^{h} - 1\\) (cas de l'arbre parfait) On peut donc en d\u00e9duire un encadrement de la taille d'un arbre binaire de fa\u00e7on g\u00e9n\u00e9rale, avec pour profondeur racine 1 : \\(n_{min} \\leq n \\leq n_{max}\\) \\(h \\leq n \\leq 2^{h} - 1\\) \u00c0 partir de l'encadrement pr\u00e9c\u00e9dent, on peut retrouver l'encadrement de la hauteur \\(h\\) : \\(\\lceil log_{2}(n+1) \\rceil \\leq h \\leq n\\)</p> </li> </ol>"},{"location":"terminale/arbres/exercices_vocabulaire/#denombrement-darbres-binaires","title":"D\u00e9nombrement d'arbres binaires","text":"<p>Exercice 5</p> <p>Dessinez et d\u00e9nombrez tous les arbres binaires possibles :</p> <ul> <li>pour une taille \\(n = 1\\),</li> <li>pour une taille \\(n = 2\\),</li> <li>pour une taille \\(n = 3\\),</li> <li>pour une taille \\(n = 4\\)</li> </ul> <p>Sans les dessiner et en vous aidant des r\u00e9ponses pr\u00e9c\u00e9dentes, d\u00e9terminez le nombre d'arbres de taille \\(n = 5\\).</p> Indice 1 exercice 5 <p>Vous pouvez d\u00e9nombrer les arbres de taille \\(n = 5\\) en faisant la somme des arbres dont les noeuds sont r\u00e9partis de la mani\u00e8re suivante :</p> <ul> <li>1 noeud racine et 4 noeuds \u00e0 droite</li> <li>1 noeud racine et 4 noeuds \u00e0 gauche</li> <li>1 noeud racine, 3 noeuds \u00e0 gauche et 1 noeud \u00e0 droite</li> <li>1 noeud racine, 1 noeud \u00e0 gauche et 3 noeud \u00e0 droite</li> <li>1 noeud racine, 2 noeuds \u00e0 gauche et 2 noeuds \u00e0 droite</li> </ul> <p></p> <p>En comptant le nombre de possibilit\u00e9s pour ces 5 cas, vous obtiendrez le nombre total d'arbres de taille \\(n = 5\\).</p> Indice 2 exercice 5 <p>Le nombre d'arbres d'une taille \\(n\\) donn\u00e9e peut \u00eatre calcul\u00e9 avec le nombre de Catalan, voir page Wikipedia pour plus d'informations. (Bien s\u00fbr, ce n'est pas au programme.)</p> <p>Donc, pour une taille \\(n = 5\\) : \\(C_{5} = \\frac{(2n)!}{(n+1)!n!} = \\frac{10!}{6!*5!} = \\frac{5040}{120} = 42\\)</p> <p>Il y a donc 42 arbres de taille 5.</p>"},{"location":"terminale/arbres/implementation_abr/","title":"Impl\u00e9mentation d'un arbre binaire de recherche","text":"<p>L'impl\u00e9mentation d'un arbre binaire de recherche peut se faire de la m\u00eame fa\u00e7on que celle d'un arbre binaire classique. On va ici r\u00e9utiliser notre classe <code>Arbre</code> cr\u00e9\u00e9e lors de l'activit\u00e9 pr\u00e9c\u00e9dente.</p> <p>Cette activit\u00e9 sera divis\u00e9e en deux parties, qui consisteront \u00e0 :</p> <ul> <li>\u00e9crire des m\u00e9thodes permettant de v\u00e9rifier si un arbre binaire est un arbre binaire de recherche,</li> <li>\u00e9crire une m\u00e9thode de recherche et d'insertion dans un arbre binaire de recherche.</li> </ul> <p>Note : Par la suite, pour simplifier la r\u00e9daction, on utilisera parfois le terme \"arbre\" pour d\u00e9signer un arbre binaire.</p> <p>Op\u00e9rations de base</p> <p>En plus des op\u00e9rations \\(est\\_vide\\), \\(est\\_feuille\\), \\(gauche\\), \\(droite\\), \\(racine\\), \\(valeur\\_racine\\) et \\(parcours\\_infixe\\) d\u00e9j\u00e0 vues, on d\u00e9finit ici de nouvelles op\u00e9rations.</p> <p>Trois op\u00e9rations visant \u00e0 v\u00e9rifier si l'arbre binaire est un arbre binaire de recherche :</p> <ul> <li>\\(maximum : Arbre \\rightarrow Int\\) : Renvoie la valeur maximale parmi les valeurs des noeuds d'un arbre binaire NON vide.</li> <li>\\(minimum : Arbre \\rightarrow Int\\) : Renvoie la valeur minimale parmi les valeurs des noeuds d'un arbre binaire NON vide.</li> <li>\\(est\\_ABR :~Arbre \\rightarrow Bool\\) : Renvoie True si un arbre binaire est un arbre binaire de recherche, False sinon.</li> </ul> <p>Dans le cas o\u00f9 l'arbre binaire est un arbre binaire de recherche, les op\u00e9rations de recherche et d'insertion sont ainsi d\u00e9finies :</p> <ul> <li>\\(rechercher :~Arbre \\times Element \\rightarrow Bool\\) : Renvoie True s'il existe un noeud de l'arbre binaire de recherche contenant la valeur donn\u00e9e, False sinon.</li> <li>\\(inserer :~Arbre \\times Element \\rightarrow Arbre\\) : Ins\u00e8re un nouveau noeud de valeur donn\u00e9e \u00e0 sa bonne position dans l'arbre binaire de recherche.</li> </ul> <p>Pour cette activit\u00e9, on \u00e9crira toutes les op\u00e9rations sous la forme de m\u00e9thodes. </p> Rappel concernant la cr\u00e9ation et l'appel de m\u00e9thodes <p>Une m\u00e9thode est une fonction d\u00e9finie \u00e0 l'int\u00e9rieur d'une classe. Elle prend toujours un param\u00e8tre self, puis \u00e9ventuellement d'autres param\u00e8tres :</p> <p><pre><code>class Arbre:\ndef __init__(self, valeur_racine=None, gauche=None, droite=None):\n# Une m\u00e9thode sp\u00e9ciale : le constructeur de la classe\n...\ndef gauche(self: 'Arbre') -&gt; 'Arbre':\n# Renvoie le sous-arbre gauche de l'arbre\n...\ndef droite(self: 'Arbre') -&gt; 'Arbre':\n# Renvoie le sous-arbre droit de l'arbre\n...\ndef est_vide(self: 'Arbre') -&gt; bool:\n# Renvoie True si l'arbre est vide, False sinon\n...\ndef est_present(self: 'Arbre', val: 'int|str') -&gt; bool:\n# Renvoie True s'il existe un noeud de valeur val dans l'arbre, False sinon\n...\n</code></pre> Lors de l'appel \u00e0 une m\u00e9thode, on ne donne pas d'argument pour le param\u00e8tre self car il correspond \u00e0 l'adresse de l'objet sur lequel elle est appel\u00e9e. Si l'on souhaite par exemple savoir si le sous-arbre gauche d'un arbre binaire dont l'adresse est stock\u00e9e dans une variable <code>ab</code> est vide, il faudra \u00e9crire : <pre><code>ab.gauche().est_vide()\n</code></pre> Si l'on souhaite maintenant savoir si le sous-arbre droit d'un arbre binaire dont l'adresse est stock\u00e9e dans une variable <code>ab</code> contient un noeud de valeur 42, il faudra \u00e9crire : <pre><code>ab.droite().est_present(42)\n</code></pre></p> <p>\u00c0 t\u00e9l\u00e9charger</p> <p>R\u00e9cup\u00e9rez le fichier suivant :</p> <ul> <li>abr.py - Classe <code>Arbre</code> \u00e0 compl\u00e9ter repr\u00e9sentant un arbre binaire avec les nouvelles m\u00e9thodes relatives aux arbres binaires de recherche.</li> </ul> Si vous souhaitez utiliser les fonctions de dessin avec Graphviz <p>Ce n'est pas obligatoire, mais si vous souhaitez, comme pour l'activit\u00e9 pr\u00e9c\u00e9dente, pouvoir afficher un dessin de votre arbre, les fichiers \u00e0 avoir sur votre machine sont toujours les m\u00eames :</p> <ul> <li>dessin.py - Quelques fonctions annexes utilis\u00e9es pour dessiner un arbre avec le module <code>Graphviz</code>. (Vous n'avez pas besoin d'ouvrir ou de modifier ce fichier.)</li> </ul> <p>Si vous utilisez les machines du lyc\u00e9e (sinon, voir cette page pour la proc\u00e9dure pour installer Graphviz chez vous) :</p> <ul> <li>windows_graphviz.zip - D\u00e9compressez l'archive dans le r\u00e9pertoire o\u00f9 se trouvent vos fichiers Python. Vous devez avoir <code>abr.py</code>, <code>dessin.py</code> et un dossier <code>Graphviz</code> au m\u00eame endroit.Contient les ex\u00e9cutables de Graphviz.</li> </ul> <p>Pour utiliser les fonctions de <code>dessin.py</code>, vous devez \u00e9galement d\u00e9-commenter la premi\u00e8re ligne <code>from dessin import dessiner</code> du fichier <code>abr.py</code>, qui a \u00e9t\u00e9 comment\u00e9e pour \u00e9viter les erreurs.</p> Corrig\u00e9 complet <p>Cliquez ici pour t\u00e9l\u00e9charger le corrig\u00e9 complet de cette activit\u00e9.</p> <p>Important</p> <p>Ici, on a fait le choix de travailler avec une structure immuable. En l'occurence, la m\u00e9thode <code>inserer</code> renvoie un nouvel arbre binaire de recherche, et ne modifie pas directement l'arbre sur lequel elle est appel\u00e9e.</p> <p>Tester son programme avec le module doctest</p> <p>Plusieurs tests ont \u00e9t\u00e9 r\u00e9dig\u00e9s dans la docstring du constructeur de la classe. Rien ne vous emp\u00eache de rajouter davantage de tests si vous le souhaitez.</p> <p>Pour tester votre programme, vous avez simplement \u00e0 ex\u00e9cuter celui-ci, et s'il n'y a pas d'erreurs, il ne se passera rien. S'il y a des erreurs, vous obtiendrez des d\u00e9tails sur les tests qui n'ont pas fonctionn\u00e9.</p> <p>Pour activer le mode \"verbeux\" et obtenir encore plus de d\u00e9tails sur les erreurs, vous pouvez passer le param\u00e8tre <code>verbose</code> \u00e0 <code>True</code> (sur la toute derni\u00e8re ligne du programme).</p>"},{"location":"terminale/arbres/implementation_abr/#maximum-et-minimum","title":"Maximum et minimum","text":"<p>Pour pouvoir \u00e9crire une m\u00e9thode permettant de d\u00e9finir si un arbre binaire est un arbre binaire de recherche, on se propose d'abord d'\u00e9crire deux m\u00e9thodes permettant de d\u00e9terminer la valeur minimale et la valeur maximale des noeuds d'un arbre binaire de mani\u00e8re g\u00e9n\u00e9rale.</p> <p>Ces deux fonctions :</p> <ul> <li>ne sont d\u00e9finies que pour des arbres binaires non vides, comme indiqu\u00e9 dans les CU (Conditions d'Utilisation) de la fonction,</li> <li>n\u00e9cessitent d'identifier un cas de base et plusieurs cas r\u00e9cursifs.</li> </ul> <p>Vous pourrez utiliser les fonctions <code>min</code> et <code>max</code> de Python, qui renvoient respectivement le minimum et le maximum parmi plusieurs \u00e9l\u00e9ments, ou parmi les \u00e9l\u00e9ments d'une liste/d'un tuple.</p> <p>Exercice 1</p> <p>\u00c9crire le code Python des m\u00e9thodes <code>minimum</code> et <code>maximum</code>.</p> Aide - Exercice 1 <p>Vous pouvez distinguer les 4 cas suivants :</p> <ul> <li>Le cas o\u00f9 l'arbre donn\u00e9 est une feuille (= sous-arbres gauche et droit vides), qui est le cas de base</li> <li>Le cas o\u00f9 le sous-arbre gauche uniquement est vide</li> <li>Le cas o\u00f9 le sous-arbre droit uniquement est vide</li> <li>Le cas o\u00f9 les deux sous-arbres sont NON vides</li> </ul> Encore plus d'aide - Exercice 1 <p>Voici une partie du code, \u00e0 compl\u00e9ter.</p> <pre><code>def minimum(self: 'Arbre') -&gt; int:\n''' Renvoie la valeur minimale des noeuds de l'arbre\n:CU: L'arbre n'est PAS vide '''\nif self.est_feuille():\n...\nelif self.gauche().est_vide():\nreturn min(self.valeur_racine(), self.droite().minimum())\nelif self.droite().est_vide():\n...\nelse:\n...\n</code></pre> Solution - Exercice 1 <pre><code>def minimum(self: 'Arbre') -&gt; int:\n''' Renvoie la valeur minimale des noeuds de l'arbre\n:CU: L'abre n'est PAS vide '''\nif self.est_feuille():\nreturn self.valeur_racine()\nelif self.gauche().est_vide():\nreturn min(self.valeur_racine(), self.droite().minimum())\nelif self.droite().est_vide():\nreturn min(self.valeur_racine(), self.gauche().minimum())\nelse:\nreturn min(self.gauche().minimum(), self.valeur_racine(), self.droite().minimum())\ndef maximum(self: 'Arbre') -&gt; int:\n''' Renvoie la valeur maximale des noeuds de l'arbre\n:CU: L'arbre n'est PAS vide '''\nif self.est_feuille():\nreturn self.valeur_racine()\nelif self.gauche().est_vide():\nreturn max(self.valeur_racine(), self.droite().maximum())\nelif self.droite().est_vide():\nreturn max(self.valeur_racine(), self.gauche().maximum())\nelse:\nreturn max(self.gauche().maximum(), self.valeur_racine(), self.droite().maximum())\n</code></pre>"},{"location":"terminale/arbres/implementation_abr/#la-methode-est_abr","title":"La m\u00e9thode <code>est_abr</code>","text":"<p>On peut maintenant \u00e9crire une m\u00e9thode qui permet de v\u00e9rifier qu'un arbre binaire cr\u00e9\u00e9 avec la classe <code>Arbre</code> soit un arbre binaire de recherche.</p> <p>Un arbre binaire est un arbre binaire de recherche si :</p> <ul> <li>l'arbre est vide ou est une feuille,</li> </ul> <p>OU BIEN</p> <ul> <li>si le sous-arbre gauche n'est pas vide, les \u00e9l\u00e9ments des noeuds du sous-arbre gauche sont tous \\(\\leq\\) \u00e0 l'\u00e9l\u00e9ment de la racine, ET</li> <li>si le sous-arbre droit n'est pas vide, les \u00e9l\u00e9ments des noeuds du sous-arbre droit sont tous \\(&gt;\\) \u00e0 l'\u00e9l\u00e9ment de la racine, ET</li> <li>les sous-arbres gauches et droit sont \u00e9galement des arbres binaires de recherche.</li> </ul> <p>La fonction <code>est_abr</code> renvoie donc False si l'une de ces conditions n'est pas remplie, et renvoie True sinon.</p> <p>Exercice 2</p> <p>\u00c9crire le code Python de la m\u00e9thode <code>est_abr</code>.</p> Aide - Exercice 2 <p>Le cas o\u00f9 l'arbre est vide ou l'arbre est une feuille est le cas de base, non r\u00e9cursif. Dans ce cas-l\u00e0, on consid\u00e8re que l'arbre est un arbre binaire de recherche. On renverra donc True si l'on se trouve dans l'un de ces deux cas.</p> <p>Il ne reste plus qu'\u00e0 v\u00e9rifier les trois autres conditions \u00e9voqu\u00e9es pr\u00e9c\u00e9demment. Une solution est de v\u00e9rifier, pour chaque condition, si elle n'est pas remplie, et de renvoyer False le cas \u00e9ch\u00e9ant. Une fois que les trois conditions ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, on renvoie donc True.</p> Encore plus d'aide - Exercice 2 <p>Voici une partie du code, \u00e0 compl\u00e9ter.</p> <pre><code>def est_ABR(self: 'Arbre') -&gt; bool:\n''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. '''\nif self.est_vide() or self.est_feuille():\nreturn ...\nelse:\nif not self.gauche().est_vide() and self.gauche().maximum() &gt; self.valeur_racine():\nreturn ...\nif ... and ... :\nreturn ...\nif ... or ... :\nreturn ...\nreturn ...\n</code></pre> Solution - Exercice 2 <pre><code>def est_ABR(self: 'Arbre') -&gt; bool:\n''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon. '''\nif self.est_vide() or self.est_feuille():\nreturn True\nelse:\nif not self.gauche().est_vide() and self.gauche().maximum() &gt; self.valeur_racine():\nreturn False\nif not self.droite().est_vide() and self.droite().minimum() &lt;= self.valeur_racine():\nreturn False\nif not self.gauche().est_ABR() or not self.droite().est_ABR():\nreturn False\nreturn True\n</code></pre> <p>Une autre solution plus simple pour v\u00e9rifier si un arbre binaire est un arbre binaire de recherche est de v\u00e9rifier si la liste des valeurs des noeuds visit\u00e9s en ordre infixe est tri\u00e9e.</p> <p>Exercice 3</p> <p>Compl\u00e9tez le corps de la m\u00e9thode <code>est_ABR_v2</code>.</p> Aide - Exercice 3 <p>Il suffit simplement de v\u00e9rifier que la liste <code>lst_valeurs</code> soit tri\u00e9e en la parcourant et en v\u00e9rifiant que chaque \u00e9l\u00e9ment soit sup\u00e9rieur \u00e0 l'\u00e9l\u00e9ment qui le pr\u00e9c\u00e8de. Si l'on se rend compte qu'un \u00e9l\u00e9ment est inf\u00e9rieur \u00e0 son pr\u00e9decesseur, on renvoie False. Sinon, on renvoie True.</p> Solution - Exercice 3 <pre><code>def est_ABR_v2(self: 'Arbre') -&gt; bool:\n''' Renvoie True si l'arbre binaire est un arbre binaire de recherche, False sinon.\nAutre version, v\u00e9rifiant si la liste des noeuds visit\u00e9s en ordre infixe est tri\u00e9e dans l'ordre croissant. '''\nlst_valeurs = self.parcours_infixe()  # R\u00e9cup\u00e9rer la liste des valeurs des noeuds visit\u00e9s en parcours infixe\nfor i in range(1, len(lst_valeurs)):\nif lst_valeurs[i] &lt; lst_valeurs[i - 1]:\nreturn False\nreturn True\n</code></pre>"},{"location":"terminale/arbres/implementation_abr/#recherche-dans-un-arbre-binaire-de-recherche","title":"Recherche dans un arbre binaire de recherche","text":"<p>\u00c0 savoir pour le bac</p> <p>L'algorithme de recherche dans un arbre binaire de recherche fait partie des algorithmes \u00e0 ma\u00eetriser pour le baccalaur\u00e9at.</p> <p>Comme cela a \u00e9t\u00e9 vu dans les exercices, la rercherche dans un arbre binaire de recherche se d\u00e9roule de la mani\u00e8re suivante.</p> <p>D\u00e9roulement <code>rechercher</code></p> <p>Pr\u00e9condition : l'arbre donn\u00e9 est un arbre binaire de recherche. L'algorithme <code>rechercher</code> se d\u00e9roule comme suit :</p> <ul> <li>Si l'arbre binaire est vide : on renvoie Faux.</li> <li>Sinon (l'arbre binaire n'est pas vide):<ul> <li>Si la valeur de la racine de l'arbre est \u00e9gale \u00e0 l'\u00e9l\u00e9ment recherch\u00e9 : on renvoie Vrai.</li> <li>Sinon, si l'\u00e9l\u00e9ment recherch\u00e9 est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine de l'arbre, <code>rechercher</code> l'\u00e9l\u00e9ment dans le sous-arbre gauche.</li> <li>Sinon, on <code>rechercher</code> l'\u00e9l\u00e9ment dans le sous-arbre droit.</li> </ul> </li> </ul> <p>Exercice 4</p> <p>En vous aidant du d\u00e9roulement d\u00e9crit ci-dessus, \u00e9crire le code Python de la m\u00e9thode <code>rechercher</code>. Remarque : On aura pas besoin de rajouter une condition dans le code pour v\u00e9rifier si l'arbre binaire est bien un arbre binaire de recherche, car cela a \u00e9t\u00e9 sp\u00e9cifi\u00e9 en tant que condition d'utilisation (CU) : <code>''' :CU: self.est_ABR() == True '''</code></p> Solution - Exercice 4 <pre><code>def rechercher(self: 'Arbre', elt: 'int|str') -&gt; bool:\n''' Recherche l'\u00e9l\u00e9ment elt dans l'arbre, renvoie True s'il est trouv\u00e9, False sinon.\n:CU: self.est_ABR() == True '''\nif self.est_vide():\nreturn False\nelif self.valeur_racine() == elt:\nreturn True\nelif elt &lt;= self.valeur_racine():\nreturn self.gauche().rechercher(elt)\nelse:\nreturn self.droite().rechercher(elt)\n</code></pre>"},{"location":"terminale/arbres/implementation_abr/#insertion-dans-un-arbre-binaire-de-recherche","title":"Insertion dans un arbre binaire de recherche","text":"<p>\u00c0 savoir pour le bac</p> <p>L'algorithme d'insertion dans un arbre binaire de recherche fait partie des algorithmes \u00e0 ma\u00eetriser pour le baccalaur\u00e9at.</p> <p>Enfin, l'insertion dans un arbre binaire de recherche est assez similaire \u00e0 la recherche.</p> <p>D\u00e9roulement <code>inserer</code></p> <p>Pr\u00e9condition : l'arbre donn\u00e9 est un arbre binaire de recherche. L'algorithme <code>inserer</code> se d\u00e9roule comme suit :</p> <ul> <li>Si l'arbre binaire est vide : on renvoie une nouvelle feuille contenant l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer.</li> <li>Sinon (l'arbre binaire n'est pas vide):<ul> <li>Si l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer est inf\u00e9rieur ou \u00e9gal \u00e0 la valeur de la racine de l'arbre, <code>inserer</code> l'\u00e9l\u00e9ment dans le sous-arbre gauche. On renvoie l'arbre r\u00e9sultant de cette insertion.</li> <li>Sinon, <code>inserer</code> l'\u00e9l\u00e9ment dans le sous-arbre droit. On renvoie l'arbre r\u00e9sultant de cette insertion.</li> </ul> </li> </ul> <p>Exercice 5</p> <p>En vous aidant du d\u00e9roulement d\u00e9crit ci-dessus, \u00e9crire le code Python de la m\u00e9thode <code>inserer</code>. Attention, <code>inserer</code> doit toujours renvoyer un objet de type <code>Arbre</code>. Remarque : Ici \u00e9galement, on aura pas besoin de rajouter une condition dans le code pour v\u00e9rifier si l'arbre binaire est bien un arbre binaire de recherche.</p> Solution - Exercice 5 <pre><code>def inserer(self: 'Arbre', elt: 'int|str') -&gt; 'Arbre':\n''' Ins\u00e8re l'\u00e9l\u00e9ment elt dans l'arbre \n:CU: self.est_ABR() == True '''\nif self.est_vide():\nreturn Arbre(elt, Arbre(), Arbre())\nelse:\nif elt &lt;= self.valeur_racine():\nreturn Arbre(self.valeur_racine(), self.gauche().inserer(elt), self.droite())\nelse:\nreturn Arbre(self.valeur_racine(), self.gauche(), self.droite().inserer(elt))\n</code></pre>"},{"location":"terminale/arbres/implementation_abr/#trier-une-liste-avec-un-arbre-binaire-de-recherche","title":"Trier une liste avec un arbre binaire de recherche","text":"<p>Exercice 6</p> <p>Compl\u00e9ter la fonction <code>trier</code> qui prend une liste d'\u00e9l\u00e9ments et renvoie une nouvelle liste contenant les m\u00eames \u00e9l\u00e9ments, mais tri\u00e9s par ordre croissant. Vous devez pour cela utiliser un arbre binaire de recherche et la m\u00e9thode <code>parcours_infixe</code>.</p> <p>Attention : Il s'agit d'une fonction plac\u00e9e en dehors de la classe, et non pas d'une m\u00e9thode de <code>Arbre</code>.</p> Aide - Exercice 6 <p>Il suffit simplement de :</p> <ul> <li>cr\u00e9er un nouvel arbre binaire de recherche vide,</li> <li>de parcourir la liste \u00e0 trier en ins\u00e9rant chaque \u00e9l\u00e9ment dans l'arbre,</li> <li>puis d'appeler la fonction <code>parcours_infixe</code> sur l'arbre cr\u00e9\u00e9 pour obtenir la liste des valeurs des n\u0153uds tri\u00e9e dans l'ordre croissant.</li> </ul> <p>Si l'on souhaite cr\u00e9er un nouvel arbre binaire vide dans une variable <code>abr</code>, on devra donc \u00e9crire : <pre><code>abr = Arbre()\n</code></pre></p> Solution - Exercice 6 <pre><code>def trier(liste: list) -&gt; list:\n''' Trie les \u00e9l\u00e9ments (int|str) d'une liste dans l'ordre croissant.\nRenvoie la liste tri\u00e9e. '''\nabr = Arbre()\nfor el in liste:\nabr = abr.inserer(el)\nreturn abr.parcours_infixe()\n</code></pre>"},{"location":"terminale/arbres/implementation_abr/#aller-plus-loin-minimum-et-maximum-dun-arbre-binaire-de-recherche","title":"Aller plus loin : minimum et maximum d'un arbre binaire de recherche","text":"<p>Pour trouver le plus petit \u00e9l\u00e9ment d'un arbre binaire de recherche, on proc\u00e8de comme suit : </p> <ul> <li>Si l'arbre n'a pas de sous-arbre gauche, son minimum est alors la valeur de sa racine. </li> <li>Sinon, il s'agit du minimum (r\u00e9cursivement) de son sous-arbre gauche. </li> </ul> <p>Pour le maximum, c'est le m\u00eame principe mais avec le sous-arbre droit.</p> <p>Exercice 7</p> <p>Compl\u00e9tez les m\u00e9thodes <code>minimum_abr</code> et <code>maximum_abr</code> qui renvoient la valeur minimale et la valeur maximale des n\u0153uds de l'arbre dans le cas d'un arbre binaire de recherche.</p> Solution - Exercice 7 <pre><code>def minimum_abr(self: 'Arbre') -&gt; int:\n''' Renvoie la valeur minimale des noeuds de l'arbre binaire de recherche\n    :CU: self.est_ABR() == True and not self.est_vide() '''\nif self.gauche().est_vide():\nreturn self.valeur_racine()\nelse:\nreturn self.gauche().minimum_abr()\ndef maximum_abr(self: 'Arbre') -&gt; int:\n''' Renvoie la valeur maximale des noeuds de l'arbre binaire de recherche\n    :CU: self.est_ABR() == True and not self.est_vide() '''\nif self.droite().est_vide():\nreturn self.valeur_racine()\nelse:\nreturn self.droite().maximum_abr()\n</code></pre>"},{"location":"terminale/arbres/implementation_arbres/","title":"Impl\u00e9mentation d'un arbre binaire","text":"<p>Il y a de nombreuses mani\u00e8res d'impl\u00e9menter un arbre binaire.</p> <p>Dans cette partie, on proposera une mani\u00e8re parmi d'autres d'impl\u00e9menter cette structure de donn\u00e9es. Pour vous entra\u00eener sur d'autres impl\u00e9mentations, voir la partie exercices.</p> <p>En langage Python, on ne peut pas avoir plusieurs constructeurs dans une classe. On aura donc un seul constucteur pouvant \u00eatre appel\u00e9 de deux fa\u00e7ons diff\u00e9rentes :</p> <ul> <li><code>Arbre()</code> : cr\u00e9ation d'un arbre binaire vide, les attributs <code>racine</code>, <code>gauche</code> et <code>droite</code> seront automatiquement affect\u00e9s \u00e0 <code>None</code>.</li> <li><code>Arbre(racine, gauche, droite)</code> : cr\u00e9ation d'un arbre binaire non vide, dont la <code>racine</code> est la valeur (l'\u00e9tiquette) du noeud racine, et <code>gauche</code> et <code>droite</code> sont \u00e9galement de type <code>Arbre</code>.</li> </ul> <p>Note : Une feuille est donc une instance  de <code>Arbre</code> dont le sous-arbre gauche et le sous-arbre droit sont des arbres vides.</p> <p>\u00c0 t\u00e9l\u00e9charger</p> <p>R\u00e9cup\u00e9rez les fichiers suivants :</p> <ul> <li>arbre_binaire.py - Classe <code>Arbre</code> \u00e0 compl\u00e9ter repr\u00e9sentant un arbre binaire.</li> <li>dessin.py - Quelques fonctions annexes utilis\u00e9es pour dessiner un arbre avec le module <code>Graphviz</code>. (Vous n'avez pas besoin d'ouvrir ou de modifier ce fichier.)</li> </ul> <p>Si vous utilisez les machines du lyc\u00e9e:</p> <ul> <li>windows_graphviz.zip - D\u00e9compressez l'archive dans le r\u00e9pertoire o\u00f9 se trouvent vos fichiers Python. Vous devez avoir <code>arbre_binaire.py</code>, <code>dessin.py</code> et un dossier <code>Graphviz</code> au m\u00eame endroit.Contient les ex\u00e9cutables de Graphviz.</li> </ul> Corrig\u00e9 complet <p>Cliquez ici pour t\u00e9l\u00e9charger le corrig\u00e9 complet des m\u00e9thodes et fonctions associ\u00e9es \u00e0 cette activit\u00e9.</p> Installation de Graphviz sur votre machine personnelle <p>Pour utiliser la fonction <code>dessiner</code>, le module <code>Graphviz</code> et les ex\u00e9cutables associ\u00e9s doivent \u00eatre install\u00e9s sur votre machine. Voici comment proc\u00e9der.</p> <p>\u00c9tape 1 - Installer le module Graphviz</p> <p>M\u00e9thode 1 :</p> <p>Dans Thonny, allez dans l'onglet \"Outils\", puis \"G\u00e9rer les paquets\". Recherchez \"graphviz\", puis cliquez sur le bouton Installer.</p> <p>M\u00e9thode 2 :</p> <p>Ouvrez l'invite de commande Windows (ou le terminal si vous utilisez Linux), puis ex\u00e9cutez simplement la commande suivante :</p> <pre><code>pip install graphviz\n</code></pre> <p>\u00c9tape 2 - Installer les ex\u00e9cutables</p> <p>Si vous \u00eates sur Windows, cliquez ici puis t\u00e9l\u00e9chargez et installez la derni\u00e8re version de Graphviz (choisissez l'<code>EXE Installer</code> correspondant \u00e0 la version de votre syst\u00e8me d'exploitation, 32 bits ou 64 bits. Si vous avez un doute, choisissez la version 32 bits ou lisez cet article pour conna\u00eetre la version de votre syst\u00e8me.)</p> <p>Si vous \u00eates sur Linux, cliquez ici puis installez le paquet <code>graphviz</code> en ex\u00e9cutant dans le terminal la commande associ\u00e9e \u00e0 votre distribution (Ubuntu, Fedora, etc.).</p> <p>Si vous \u00eates sur macOS, cliquez ici puis ex\u00e9cutez l'une des commandes indiqu\u00e9es.</p>"},{"location":"terminale/arbres/implementation_arbres/#operations-de-base","title":"Op\u00e9rations de base","text":"<p>Int\u00e9ressons-nous d'abord aux op\u00e9rations de base pouvant \u00eatre effectu\u00e9es sur notre arbre.</p> <p>On d\u00e9finira ces op\u00e9rations sous les deux formes suivantes :</p> <ul> <li>avec des m\u00e9thodes dans notre classe,</li> <li>avec des fonctions d'interface en dehors de la classe, qui prendront un objet de type <code>Arbre</code> en entr\u00e9e.</li> </ul> <p>Note</p> <p>On pourra donc effectuer nos op\u00e9rations de base de deux mani\u00e8res diff\u00e9rentes. Si l'on cr\u00e9e un arbre binaire dans une variable <code>mon_arbre</code> et que l'on souhaite, par exemple, r\u00e9cup\u00e9rer la valeur de sa racine, on pourra soit \u00e9crire <code>valeur_racine(mon_arbre)</code>, soit <code>mon_arbre.valeur_racine()</code>.</p> <p>On a choisi de faire ainsi pour simplifier les choses et \u00e9viter les confusions, mais il faut bien faire la diff\u00e9rences entre l'appel de m\u00e9thodes associ\u00e9es \u00e0 un objet, et l'appel de fonctions d\u00e9finies hors d'une classe.</p> <pre><code>''' Classe impl\u00e9mentant un Arbre Binaire. '''\nclass Arbre:\ndef __init__(self, valeur=None, gauche=None, droite=None):\n''' Cr\u00e9e un nouvel arbre binaire.\n        :param valeur: (int|str) La valeur du noeud racine, soit un entier, soit une cha\u00eene de caract\u00e8res\n        :param gauche: (Arbre) Le sous-arbre binaire gauche (None pour arbre binaire vide)\n        :param droite: (Arbre) Le sous-arbre binaire droit (None pour arbre binaire vide)\n        :CU: Si valeur est \u00e0 None, gauche et droite doivent \u00eatre \u00e9galement \u00e0 None (cas de l'arbre vide),\n        sinon, gauche et droite doivent \u00eatre de type Arbre. '''\nassert (valeur == None and gauche == None and droite == None) or \\\n               (type(valeur) in (int, str) and type(gauche) == Arbre and type(droite) == Arbre)\nself.v = valeur\nself.g = gauche\nself.d = droite\ndef est_vide(self):\n''' Renvoie True si l'arbre binaire est vide, False s'il ne l'est pas. '''\npass\ndef racine(self):\n''' Renvoie le Noeud racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\npass\ndef valeur_racine(self):\n''' Renvoie la valeur de la racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\npass\ndef gauche(self):\n''' Renvoie le sous-arbre gauche de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\npass\ndef droite(self):\n''' Renvoie le sous-arbre droit de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\npass\ndef est_feuille(self):\n''' Renvoie True si l'arbre binaire est une feuille, False s'il ne l'est pas.\n        :CU: L'arbre n'est PAS vide '''\npass\n# Les fonctions d'interface (vous pouvez les utiliser au lieu des m\u00e9thodes, au choix), \u00e0 compl\u00e9ter :\ndef est_vide(ab: Arbre) -&gt; bool:\n''' Renvoie True si l'arbre binaire ab est vide, False sinon. '''\npass\ndef racine(ab: Arbre) -&gt; Arbre:\n''' Renvoie le Noeud racine de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\npass\ndef valeur_racine(ab: Arbre) -&gt; 'int|str':\n''' Renvoie la valeur de la racine de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\npass\ndef gauche(ab: Arbre) -&gt; Arbre:\n''' Renvoie le sous-arbre gauche de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\npass\ndef droite(ab: Arbre) -&gt; Arbre:\n''' Renvoie le sous-arbre droit de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\npass\ndef est_feuille(ab: Arbre) -&gt; bool:\n''' Renvoie True si l'arbre binaire est une feuille, False s'il ne l'est pas.\n    :CU: L'arbre n'est PAS vide '''\npass\n</code></pre> <p>Important</p> <p>Dans cette impl\u00e9mentation, on n'utilise pas de classe <code>Noeud</code> pour repr\u00e9senter les noeuds de l'arbre (ce qui diff\u00e8re du type abstrait). On consid\u00e8re que le noeud racine d'un arbre est l'arbre lui-m\u00eame. La m\u00e9thode nomm\u00e9e <code>racine</code> renverra donc simplement l'adresse de l'instance de la classe <code>Arbre</code>.</p> <p>\u00c0 faire</p> <p>Compl\u00e9tez le corps de chaque m\u00e9thode de la classe <code>Arbre</code>.</p> Solution <pre><code>''' Classe impl\u00e9mentant un Arbre Binaire. '''\nclass Arbre:\ndef __init__(self, valeur=None, gauche=None, droite=None):\n''' Cr\u00e9e un nouvel arbre binaire.\n        :param valeur: (int|str) La valeur du noeud racine, soit un entier, soit une cha\u00eene de caract\u00e8res\n        :param gauche: (Arbre) Le sous-arbre binaire gauche (None pour arbre binaire vide)\n        :param droite: (Arbre) Le sous-arbre binaire droit (None pour arbre binaire vide)\n        :CU: Si valeur est \u00e0 None, gauche et droite doivent \u00eatre \u00e9galement \u00e0 None (cas de l'arbre vide),\n        sinon, gauche et droite doivent \u00eatre de type Arbre. '''\nassert (valeur == None and gauche == None and droite == None) or \\\n               (type(valeur) in (int, str) and type(gauche) == Arbre and type(droite) == Arbre)\nself.v = valeur\nself.g = gauche\nself.d = droite\ndef est_vide(self):\n''' Renvoie True si l'arbre binaire est vide, False s'il ne l'est pas. '''\nreturn self.v == None\ndef racine(self):\n''' Renvoie le Noeud racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\nreturn self\ndef valeur_racine(self):\n''' Renvoie la valeur de la racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\nreturn self.v\ndef gauche(self):\n''' Renvoie le sous-arbre gauche de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\nreturn self.g\ndef droite(self):\n''' Renvoie le sous-arbre droit de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\nreturn self.d\ndef est_feuille(self):\n''' Renvoie True si l'arbre binaire est une feuille, False s'il ne l'est pas.\n        :CU: L'arbre n'est PAS vide '''\nreturn self.gauche().est_vide() and self.droite().est_vide()\n# Les fonctions d'interface (vous pouvez les utiliser au lieu des m\u00e9thodes de classe, au choix) :\ndef est_vide(ab: Arbre) -&gt; bool:\n''' Renvoie True si l'arbre binaire ab est vide, False sinon. '''\nreturn ab.v == None\ndef racine(ab: Arbre) -&gt; Arbre:\n''' Renvoie le Noeud racine de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\nreturn ab\ndef valeur_racine(ab: Arbre) -&gt; 'int|str':\n''' Renvoie la valeur de la racine de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\nreturn ab.v\ndef gauche(ab: Arbre) -&gt; Arbre:\n''' Renvoie le sous-arbre gauche de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\nreturn ab.g\ndef droite(ab: Arbre) -&gt; Arbre:\n''' Renvoie le sous-arbre droit de l'arbre binaire.\n    :CU: L'arbre n'est PAS vide '''\nreturn ab.d\ndef est_feuille(ab: Arbre) -&gt; bool:\n''' Renvoie True si l'arbre binaire est une feuille, False s'il ne l'est pas.\n    :CU: L'arbre n'est PAS vide '''\nreturn est_vide(gauche(ab)) and est_vide(droite(ab))\n</code></pre>"},{"location":"terminale/arbres/implementation_arbres/#creation-dun-nouvel-arbre","title":"Cr\u00e9ation d'un nouvel arbre","text":"<p>Essayons de cr\u00e9er l'arbre suivant en utilisant notre classe <code>Arbre</code> :</p> <p> </p> Arbre binaire cr\u00e9\u00e9 avec la classe Arbre <p>Note</p> <p>L'affichage avec <code>Graphviz</code> ne permettant pas toujours de bien distinguer visuellement les sous-arbres gauches des sous-arbres droits, on a ajout\u00e9 l'information <code>G</code> ou <code>D</code> sur chaque ar\u00eate, indiquant respectivement qu'il s'agit du sous-arbre gauche ou du sous-arbre droit.</p> <p>Voici une instruction permettant de cr\u00e9er cet arbre \u00e0 l'aide de notre classe <code>Arbre</code> et de le stocker dans une variable <code>a</code> :</p> <pre><code>    ab = Arbre('C',\nArbre('A',\nArbre(),\nArbre('H',\nArbre('D', Arbre(), Arbre()),\nArbre('F', Arbre(), Arbre())\n)\n),\nArbre('B',\nArbre('G', Arbre(), Arbre()),\nArbre('E', Arbre(), Arbre())\n)\n)\n</code></pre> <p>Bien s\u00fbr, on aurait pu l'\u00e9crire sur une seule ligne :</p> <pre><code>    ab = Arbre('C', Arbre('A', Arbre(), Arbre('H', Arbre('D', Arbre(), Arbre()), Arbre('F', Arbre(), Arbre()))), Arbre('B', Arbre('G', Arbre(), Arbre()), Arbre('E', Arbre(), Arbre())))\n</code></pre> <p>On aurait \u00e9galement pu cr\u00e9er plusieurs variables de mani\u00e8re \u00e0 d\u00e9composer l'arbre :</p> <pre><code>    # Cr\u00e9ation des feuilles\nfd = Arbre('D', Arbre(), Arbre())\nff = Arbre('F', Arbre(), Arbre())\nfg = Arbre('G', Arbre(), Arbre())\nfe = Arbre('E', Arbre(), Arbre())\n# Cr\u00e9ation des sous-arbres\nsah = Arbre('H', fd, ff)\nsab = Arbre('B', fg, fe)\nsaa = Arbre('A', Arbre(), sah)\n# Cr\u00e9ation de l'arbre final\nab = Arbre('C', saa, sab)\n</code></pre> <p>Enfin, pour dessiner cet arbre, on peut utiliser la fonction dessiner import\u00e9e depuis <code>dessin.py</code> :</p> <pre><code>    dessiner(ab)\n</code></pre> <p>Si l'on souhaite acc\u00e9der par exemple au noeud ayant pour valeur B, qui est \u00e9quivalent \u00e0 l'arbre dont <code>valeur_racine() == 'B'</code>, on utilisera l'instruction :</p> <p><pre><code>    droite(ab).racine()\n</code></pre> ou simplement</p> <pre><code>    droite(ab)\n</code></pre> <p>et si on veut r\u00e9cup\u00e9rer la valeur de ce noeud :</p> <pre><code>    droite(ab).valeur_racine()\n</code></pre> <p>\u00c0 faire</p> <p>Comment r\u00e9cup\u00e9rer la feuille ayant pour valeur D ?</p> Solution <p><pre><code>    gauche(ab).droite().gauche().racine()\n</code></pre> ou simplement</p> <pre><code>    gauche(ab).droite().gauche()\n</code></pre> <p>et pour r\u00e9cup\u00e9rer la valeur qu'elle contient :</p> <pre><code>    gauche(ab).droite().gauche().valeur_racine()\n</code></pre>"},{"location":"terminale/arbres/implementation_arbres/#quelques-mesures-sur-les-arbres","title":"Quelques mesures sur les arbres","text":"<p>Important</p> <p>Pour les mesures suivantes, on consid\u00e8rera que la profondeur du noeud racine est de 0. Ainsi, on consid\u00e8rera que la hauteur de l'arbre vide est de -1. Il s'agit d'un choix arbitraire, on aurait tr\u00e8s bien pu choisir une profondeur de 1 pour le noeud racine (auquel cas l'arbre vide serait de hauteur 0).</p> <p>On rappelle que pour \u00e9crire des fonctions de mani\u00e8re r\u00e9cursive, vous devez toujours distinguer :</p> <ul> <li>au moins un cas de base (condition d'arr\u00eat), qui ici peut \u00eatre par exemple le cas o\u00f9 l'arbre est vide ou encore le cas o\u00f9 l'arbre est une feuille. Un cas de base est un cas non r\u00e9cursif, pour lequel la valeur renvoy\u00e9e par la fonction est directement d\u00e9finie.</li> <li>au moins un cas g\u00e9n\u00e9ral, ou cas r\u00e9cursif, c'est-\u00e0-dire un cas dans lequel la fonction est appel\u00e9e r\u00e9cursivement et o\u00f9 le r\u00e9sultat renvoy\u00e9 est calcul\u00e9 en utilisant le r\u00e9sultat du (ou des) appel(s) r\u00e9cursif(s). \u00c0 chaque appel r\u00e9cursif, la valeur d'au moins un des param\u00e8tres de la fonction doit changer, de mani\u00e8re \u00e0 converger vers le cas de base.</li> </ul> <p>\u00c0 faire</p> <p>Compl\u00e9tez les fonctions <code>taille</code>, <code>hauteur</code>, <code>nb_feuilles</code> et <code>est_present</code>. Ces fonctions doivent \u00eatre \u00e9crites de mani\u00e8re r\u00e9cursive.</p> Indice pour la fonction <code>taille</code> <p>Pour \u00e9crire cette fonction, qui doit fonctionner autant sur un arbre vide que sur un arbre non vide, il convient d'abord de d\u00e9terminer un cas de base, c'est-\u00e0-dire un cas non r\u00e9cursif de mani\u00e8re \u00e0 ce que l'algorithme s'arr\u00eate \u00e0 un moment donn\u00e9. Sur quel type d'arbres la fonction <code>taille</code> renverra toujours la m\u00eame valeur ?</p> <ul> <li>Si l'on cherche la taille d'un arbre vide, on obtiendra toujours 0 car un arbre vide ne contient pas de noeuds. C'est donc l\u00e0 notre cas de base.</li> </ul> <p>Ensuite, il faut d\u00e9termine un cas g\u00e9n\u00e9ral, c'est-\u00e0-dire un cas o\u00f9 l'on effectue un ou plusieurs appels r\u00e9cursifs \u00e0 <code>taille</code>.</p> <ul> <li>Si l'on cherche la taille d'un arbre non vide, c'est-\u00e0-dire d'un arbre constitu\u00e9 d'un noeud racine, d'un sous-arbre gauche et d'un sous-arbre droit, on peut alors \u00e9tablir que la taille de l'arbre correspond \u00e0 1 (on compte le noeud racine) + la taille du sous-arbre gauche + la taille du sous-arbre droit.Au fur et \u00e0 mesure des appels r\u00e9cursifs, on convergera vers le cas o\u00f9 l'arbre est vide, et donc la fonction finira par se terminer.</li> </ul> <p>Maintenant que l'on a d\u00e9termin\u00e9 ces deux cas en fran\u00e7ais, il ne reste plus qu'\u00e0 les retranscrire en Python.</p> Indice pour la fonction <code>hauteur</code> <p>Cette fonction est assez proche de la fonction <code>taille</code>. On doit pouvoir d\u00e9terminer la hauteur d'un arbre vide ou non.</p> <p>La profondeur du noeud racine est de 0.</p> <ul> <li>On consid\u00e8rera que la hauteur d'un arbre vide est toujours de -1, ce sera donc le cas de base.</li> <li>Pour le cas g\u00e9n\u00e9ral (arbre non vide), il faut compter la racine, donc ajouter 1 \u00e0 la hauteur de l'arbre, puis y ajouter la plus grande hauteur entre celle du sous-arbre gauche et celle du sous-arbre droit (appels r\u00e9cursifs).</li> </ul> <p>Note : La fonction Python <code>max</code> permet de d\u00e9terminer la plus grande valeur enti\u00e8re parmi plusieurs valeurs.</p> Solutions <pre><code>def taille(ab: Arbre) -&gt; int:\n''' Renvoie la taille d'un arbre. '''\nif ab.est_vide():\nreturn 0\nelse:\nreturn 1 + taille(gauche(ab)) + taille(droite(ab))\ndef hauteur(ab: Arbre) -&gt; int:\n''' Renvoie la hauteur d'un arbre. '''\nif est_vide(ab):\nreturn -1\nelse:\nreturn 1 + max(hauteur(gauche(ab)), hauteur(ab.droite()))\ndef nb_feuilles(ab: Arbre) -&gt; int:\n''' Renvoie le nombre de feuilles d'un arbre binaire. '''\nif est_vide(ab):\nreturn 0\nelif est_feuille(ab):\nreturn 1\nelse:\nreturn nb_feuilles(gauche(a)) + nb_feuilles(droite(a))\ndef est_present(ab: Arbre, el: 'int|str') -&gt; bool:\n''' Renvoie True si un noeud contenant l'\u00e9l\u00e9ment el est pr\u00e9sent dans l'arbre, False sinon. '''\nif est_vide(ab):\nreturn False\nelif valeur_racine(ab) == el:\nreturn True\nelse:\nreturn est_present(gauche(a), el) or est_present(droite(a), el)\n</code></pre>"},{"location":"terminale/arbres/implementation_arbres/#parcours-darbres","title":"Parcours d'arbres","text":""},{"location":"terminale/arbres/implementation_arbres/#parcours-en-profondeur","title":"Parcours en profondeur","text":"<p>On rappelle le d\u00e9roulement des parcours pr\u00e9fixe, infixe et suffixe (ou postfixe). Dans notre impl\u00e9mentation, on se contentera d'afficher les noeuds visit\u00e9s :</p> <p>D\u00e9roulement parcours pr\u00e9fixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours_pr\u00e9fixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On <code>affiche</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol> <p>D\u00e9roulement parcours suffixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours_suffixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours suffixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours suffixe</code> du sous-arbre droit (s'il est NON vide).</li> <li>On <code>affiche</code> le n\u0153ud racine de l'arbre.</li> </ol> <p>D\u00e9roulement parcours infixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours_infixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours infixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On <code>affiche</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours infixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol> <p>\u00c0 faire</p> <p>Impl\u00e9mentez les algorithmes de parcours en profondeur pr\u00e9fixe, infixe et postfixe de mani\u00e8re r\u00e9cursive.</p> Solutions <p>On a d\u00e9fini chaque parcours de deux fa\u00e7ons diff\u00e9rentes :</p> <ul> <li>une fonction qui ne renvoie rien et se contente d'afficher chaque valeur de n\u0153ud en suivant l'ordre de parcours en question,</li> <li>une fonction qui renvoie une liste contenant les valeurs des n\u0153uds visit\u00e9s selon l'ordre de parcours en question.</li> </ul> <pre><code>def parcours_prefixe(ab: Arbre) -&gt; None:\n''' Affiche les valeurs des noeuds de l'arbre parcourus en ordre pr\u00e9fixe. '''\nprint(valeur_racine(ab))\nif not est_vide(gauche(ab)):\nparcours_prefixe(gauche(ab))\nif not est_vide(droite(ab)):\nparcours_prefixe(droite(ab))\ndef parcours_prefixe_l(ab: Arbre) -&gt; list:\n''' Renvoie une liste des valeurs des noeuds de l'arbre parcourus en ordre pr\u00e9fixe. '''\nres = [valeur_racine(ab)]\nif not est_vide(gauche(ab)):\nres += parcours_prefixe_l(gauche(ab))\nif not est_vide(droite(ab)):\nres += parcours_prefixe_l(droite(ab))\nreturn res\ndef parcours_suffixe(ab: Arbre) -&gt; None:\n''' Affiche les valeurs des noeuds de l'arbre parcourus en ordre suffixe. '''\nif not est_vide(gauche(ab)):\nparcours_suffixe(gauche(ab))\nif not est_vide(droite(ab)):\nparcours_suffixe(droite(ab))\nprint(valeur_racine(ab))\ndef parcours_suffixe_l(ab: Arbre) -&gt; list:\n''' Renvoie une liste des valeurs des noeuds de l'arbre parcourus en ordre suffixe. '''\nres = []\nif not est_vide(gauche(ab)):\nres += parcours_suffixe_l(gauche(ab))\nif not est_vide(droite(ab)):\nres += parcours_suffixe_l(droite(ab))\nres += [valeur_racine(ab)]\nreturn res\ndef parcours_infixe(ab: Arbre) -&gt; None:\n''' Affiche les valeurs des noeuds de l'arbre parcourus en ordre infixe. '''\nif not est_vide(gauche(ab)):\nparcours_infixe(gauche(ab))\nprint(valeur_racine(ab))\nif not est_vide(droite(ab)):\nparcours_infixe(droite(ab))\ndef parcours_infixe_l(ab: Arbre) -&gt; list:\n''' Renvoie une liste des valeurs des noeuds de l'arbre parcourus en ordre infixe. '''\nres = []\nif not est_vide(gauche(ab)):\nres += parcours_infixe_l(gauche(ab))\nres += [valeur_racine(ab)]\nif not est_vide(droite(ab)):\nres += parcours_infixe_l(droite(ab))\nreturn res\n</code></pre>"},{"location":"terminale/arbres/implementation_arbres/#parcours-en-largeur","title":"Parcours en largeur","text":"<p>Contrairement aux algorithmes de parcours en profondeur, on impl\u00e9mentera le parcours en largeur de mani\u00e8re it\u00e9rative et non r\u00e9cursive.</p> <p>On utilisera une structure de file pour stocker les noeuds \u00e0 visiter, qu'on choisira de repr\u00e9senter par une liste Python. Les op\u00e9rations sur cette file sont les suivantes :</p> <ul> <li><code>file.pop(0)</code> : d\u00e9filer (r\u00e9cup\u00e9rer le premier \u00e9l\u00e9ment de la file et le retirer de la file),</li> <li><code>file.append(element)</code> : enfiler (ajouter un \u00e9l\u00e9ment \u00e0 la fin de la file).</li> </ul> <p>Voici le d\u00e9roulement du parcours en largeur :</p> <p>D\u00e9roulement parcours en largeur</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours_en_largeur</code> se d\u00e9roule comme suit :</p> <ol> <li>On <code>cr\u00e9e</code> une nouvelle file vide.</li> <li>On <code>enfile</code> dedans le noeud racine de l'arbre (qui est, dans notre impl\u00e9mentation, \u00e9quivalent \u00e0 l'arbre lui-m\u00eame).</li> <li>TANT QUE la file n'est PAS vide :<ol> <li>On <code>d\u00e9file</code> la file et on stocke le noeud r\u00e9cup\u00e9r\u00e9 dans une variable.</li> <li>On <code>affiche</code> la valeur du noeud r\u00e9cup\u00e9r\u00e9.</li> <li>Si le sous-arbre gauche \u00e0 ce noeud n'est PAS vide, on l'<code>enfile</code> dans la file.</li> <li>Si le sous-arbre droit \u00e0 ce noeud n'est PAS vide, on l'<code>enfile</code> dans la file.</li> </ol> </li> </ol> <p>\u00c0 faire</p> <p>Impl\u00e9mentez l'algorithme de parcours en largeur.</p> Solution <pre><code>def parcours_en_largeur(ab: Arbre) -&gt; None:\n''' Affiche les valeurs des noeuds de l'arbre parcourus en largeur.\n    :CU: L'arbre a est NON VIDE '''\nfile = []\nfile.append(racine(ab))\nwhile file:\nn = file.pop(0)\nprint(valeur_racine(n))\nif not est_vide(gauche(n)):\nfile.append(gauche(n))\nif not est_vide(droite(n)):\nfile.append(droite(n))\n</code></pre>"},{"location":"terminale/arbres/implementations_arbres/","title":"Sujets de bac sur les arbres","text":""},{"location":"terminale/arbres/implementations_arbres/#sur-les-arbres-binaires","title":"Sur les arbres binaires","text":"<p>Voici quelques sujets pour vous entra\u00eener sur les arbres binaires :</p>"},{"location":"terminale/arbres/implementations_arbres/#implementations-avec-un-dictionnaire","title":"Impl\u00e9mentations avec un dictionnaire","text":"<ul> <li>Extrait J1AS1 2022</li> <li>Extrait J1G11 2022</li> </ul>"},{"location":"terminale/arbres/implementations_arbres/#implementation-avec-une-classe-noeud","title":"Impl\u00e9mentation avec une classe Noeud","text":"<ul> <li>Extrait J2AS1 2022</li> </ul>"},{"location":"terminale/arbres/implementations_arbres/#autres-sujets","title":"Autres sujets","text":"<ul> <li>Extrait Nouvelle-Caledonie 2022</li> <li>Extrait J2AN1 2022</li> </ul>"},{"location":"terminale/arbres/implementations_arbres/#sur-les-arbres-binaires-de-recherche","title":"Sur les arbres binaires de recherche","text":"<ul> <li>Extrait sujet z\u00e9ro A 2023</li> <li>Extrait sujet z\u00e9ro B 2023</li> <li>Extrait J2ME1 2022</li> <li>Extrait J1AN1 2022</li> <li>Extrait J2LR1 2022</li> </ul>"},{"location":"terminale/arbres/parcours/","title":"Parcours d'arbres","text":"<p>D\u00e9finition : Un parcours d'arbre est un type d'algorithme consistant \u00e0 visiter les noeuds d'un arbre en suivant un certain ordre.</p> <p>Pourquoi parcourir ?</p> <ul> <li>Rechercher si un arbre contient une valeur particuli\u00e8re.</li> <li>Compter les noeuds qui contiennent une valeur donn\u00e9e.</li> <li>etc.</li> </ul> <p>Il existe deux fa\u00e7ons de parcourir un arbre :</p> <ul> <li>le parcours en profondeur</li> <li>le parcours en largeur</li> </ul> <p>Voici un arbre binaire que l'on souhaite parcourir :</p> <p></p>"},{"location":"terminale/arbres/parcours/#le-parcours-en-largeur-dabord","title":"Le parcours en largeur d'abord","text":"<p>Le parcours en largeur consiste \u00e0 parcourir l'arbre niveau par niveau. Le noeud de niveau (ou profondeur) 0 (ou 1 selon la convention choisie pour la profondeur), c'est-\u00e0-dire le noeud racine, est d'abord parcouru, puis les noeuds de niveau 1 (ou 2), et ainsi de suite. \u00c0 chaque niveau, les noeuds sont parcourus de gauche \u00e0 droite.</p> <p>Note : On peut parler de parcours en largeur \"d'abord\", car m\u00eame si le parcours est d'abord effectu\u00e9 en largeur, l'arbre est bien s\u00fbr ensuite visit\u00e9 en profondeur (on visite les noeuds d'un niveau de l'arbre, puis on passe au niveau suivant, etc.)</p> <p>Sur l'arbre ci-dessous : <code>[E, B, G, A, D, F, H, C]</code></p> <p></p>"},{"location":"terminale/arbres/parcours/#deroulement-du-parcours-en-largeur","title":"D\u00e9roulement du parcours en largeur","text":"<p>Initialement, on a deux listes : <code>\u00e0 visiter = [E]</code> <code>visit\u00e9s = []</code></p> <p>On visite E (on le retire de la liste des noeuds \u00e0 visiter et on l'ajoute dans celle des noeuds visit\u00e9s), puis on ajoute ses noeuds fils (d'abord gauche, puis droit) \u00e0 la fin des noeuds \u00e0 visiter. <code>\u00e0 visiter = [B, G]</code> <code>visit\u00e9s = [E]</code></p> <p>On visite le premier noeud B de la liste <code>\u00e0 visiter</code> (on l'ajoute \u00e0 la fin de la liste des noeuds visit\u00e9s), puis on ajoute ses noeuds fils \u00e0 la fin de la liste des noeuds \u00e0 visiter : <code>\u00e0 visiter = [G, A, D]</code> <code>visit\u00e9s = [E, B]</code></p> <p>On continue avec le noeud G : <code>\u00e0 visiter = [A, D, F, H]</code> <code>visit\u00e9s = [E, B, G]</code></p> <p>On continue avec le noeud A (qui n'a pas de fils, donc on ajoute rien dans les noeuds \u00e0 visiter) : <code>\u00e0 visiter = [D, F, H]</code> <code>visit\u00e9s = [E, B, G, A]</code></p> <p>Et ainsi de suite... <code>\u00e0 visiter = [F, H, C]</code> <code>visit\u00e9s = [E, B, G, A, D]</code></p> <p><code>\u00e0 visiter = [H, C]</code> <code>visit\u00e9s = [E, B, G, A, D, F]</code></p> <p><code>\u00e0 visiter = [C]</code> <code>visit\u00e9s = [E, B, G, A, D, F, H]</code></p> <p><code>\u00e0 visiter = []</code> <code>visit\u00e9s = [E, B, G, A, D, F, H, C]</code></p> <p>Note</p> <p>Les premiers noeuds ajout\u00e9s dans <code>\u00e0 visiter</code> sont les premiers noeuds visit\u00e9s. Si l'on impl\u00e9mentait cet algorithme, on pourrait donc utiliser une structure de file, car on ajoute les noeuds \u00e0 la fin, et on les retire au d\u00e9but.</p>"},{"location":"terminale/arbres/parcours/#le-parcours-en-profondeur-dabord","title":"Le parcours en profondeur d'abord","text":"<p>Le parcours en profondeur d'un arbre est un type de parcours d'arbres qui consiste \u00e0 traiter la racine de l'arbre, et \u00e0 parcourir r\u00e9cursivement les sous-arbres gauche et droit de la racine.</p> <p>Les parcours pr\u00e9fixe, infixe et suffixe (\u00e9galement appel\u00e9 postfixe) se distinguent par l'ordre dans lequel sont effectu\u00e9s ces traitements.</p>"},{"location":"terminale/arbres/parcours/#parcours-prefixe-racine-gauche-droite","title":"Parcours pr\u00e9fixe - (Racine-Gauche-Droite)","text":"<p>Dans le parcours pr\u00e9fixe, la racine est trait\u00e9e avant les appels r\u00e9cursifs sur le sous-arbre gauche, puis sur le sous-arbre droit.</p> <p>D\u00e9roulement du parcours pr\u00e9fixe</p> <p>Pr\u00e9condition : L\u2019arbre n\u2019est pas vide Le parcours pr\u00e9fixe se d\u00e9roule comme suit :</p> <ol> <li>On <code>visite</code> le noeud racine de l\u2019arbre.</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre gauche (s\u2019il est NON vide).</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre droit (s\u2019il est NON vide).</li> </ol> <p>(La fonction <code>visite</code> reste \u00e0 d\u00e9finir, cela pourrait \u00eatre un simple affichage.)</p> <p>Une technique visuelle : En se \"baladant\" autour de l'arbre (ordre de visite des noeuds en pointill\u00e9s), on liste chaque noeud la premi\u00e8re fois qu\u2019on le rencontre dans la balade.</p> <p>Sur l'arbre ci-dessous : <code>[E, B, A, D, C, G, F, H]</code></p> <p></p>"},{"location":"terminale/arbres/parcours/#parcours-suffixe-ou-postfixe-gauche-droite-racine","title":"Parcours suffixe ou postfixe - (Gauche-Droite-Racine)","text":"<p>Dans le parcours suffixe (ou postfixe), la racine est trait\u00e9e apr\u00e8s les appels r\u00e9cursifs sur le sous-arbre gauche puis sur le sous-arbre droit.</p> <p>D\u00e9roulement du parcours suffixe</p> <p>Pr\u00e9condition : L\u2019arbre n\u2019est pas vide Le parcours suffixe se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours suffixe</code> du sous-arbre gauche (s\u2019il est NON vide).</li> <li>On effectue le <code>parcours suffixe</code> du sous-arbre droit (s\u2019il est NON vide).</li> <li>On <code>visite</code> le noeud racine de l\u2019arbre.</li> </ol> <p>Une technique visuelle : En se \"baladant\" autour de l'arbre, on liste chaque noeud la derni\u00e8re fois qu\u2019on le rencontre dans la balade.</p> <p>Sur l'arbre ci-dessous : <code>[A, C, D, B, F, H, G, E]</code></p> <p></p>"},{"location":"terminale/arbres/parcours/#parcours-infixe-gauche-racine-droite","title":"Parcours infixe - (Gauche-Racine-Droite)","text":"<p>Dans le parcours infixe, le traitement de la racine est effectu\u00e9 entre les appels sur les sous-arbres gauche et droit.</p> <p>D\u00e9roulement du parcours infixe</p> <p>Pr\u00e9condition : L\u2019arbre n\u2019est pas vide Le parcours infixe se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours infixe</code> du sous-arbre gauche (s\u2019il est NON vide).</li> <li>On <code>visite</code> le noeud racine de l\u2019arbre.</li> <li>On effectue le <code>parcours infixe</code> du sous-arbre droit (s\u2019il est NON vide).</li> </ol> <p>Une technique visuelle : En se \"baladant\" autour de l'arbre, on liste chaque noeud ayant un fils gauche la seconde fois qu\u2019on le voit et chaque noeud sans fils gauche la premi\u00e8re fois qu\u2019on le voit.</p> <p>Sur l'arbre ci-dessous : <code>[A, B, C, D, E, F, G, H]</code></p> <p></p>"},{"location":"terminale/arbres/parcours/#autre-methode","title":"Autre m\u00e9thode","text":"<p>On peut \u00e9galement retrouver visuellement les trois parcours pr\u00e9fixe, infixe et postfixe en ajoutant les sous-arbres vides (et ar\u00eates associ\u00e9es) au dessin d'un arbre binaire. Si on trace \u00e0 pr\u00e9sent le contour de l'arbre :</p> <ul> <li>l'ordre pr\u00e9fixe est obtenu en listant les noeuds lorsque l'on passe \u00e0 leur gauche,</li> <li>l'ordre suffixe est obtenu en listant les noeuds lorsque l'on passe \u00e0 leur droite,</li> <li>l'ordre infixe est obtenu en listant les noeuds lorsque l'on passe en dessous.</li> </ul> <p>Pour vous entra\u00eener : voir cette fiche d'exercices.</p>"},{"location":"terminale/arbres/type_abstrait/","title":"Type abstrait Arbre binaire","text":"<p>Nous avons vu ce qu'\u00e9tait un arbre binaire, ainsi que le vocabulaire g\u00e9n\u00e9ral et les diff\u00e9rentes mesures sur les arbres.</p> <p>Avant de passer \u00e0 la partie impl\u00e9mentation, proposons une interface minimale du type abstrait <code>Arbre</code>.</p> <p>Note</p> <p>Dans toute la suite du cours, on utilisera le type <code>Arbre</code> pour d\u00e9signer un arbre binaire.</p> <p>On rappelle qu'un arbre binaire est soit :</p> <ul> <li>un arbre vide</li> <li>un arbre caract\u00e9ris\u00e9 par un noeud racine, un sous-arbre gauche et un sous-arbre droit, eux-m\u00eames \u00e9tant des arbres binaires.</li> </ul> <p>Type abstrait Arbre</p> <p>Utilise : Noeud, Element, Bool Op\u00e9rations : \\(nvABV :~\\rightarrow Arbre\\) \\(nvAB :~Noeud \\times Arbre \\times Arbre \\rightarrow  Arbre\\) \\(racine :~Arbre \\rightarrow Noeud\\) \\(gauche :~Arbre \\rightarrow Arbre\\) \\(droite :~Arbre \\rightarrow Arbre\\) \\(contenu :~Noeud \\rightarrow Element\\) \\(est\\_vide :~Arbre \\rightarrow Bool\\) Pr\u00e9conditions (\\(a\\) : Arbre) : \\(racine(a)\\) est d\u00e9fini si et seulement si \\(\\neg est\\_vide(a)\\) \\(gauche(a)\\) est d\u00e9fini si et seulement si \\(\\neg est\\_vide(a)\\) \\(droite(a)\\) est d\u00e9fini si et seulement si \\(\\neg est\\_vide(a)\\)</p>"},{"location":"terminale/arbres/vocabulaire/","title":"Arbres : d\u00e9finitions et vocabulaire","text":""},{"location":"terminale/arbres/vocabulaire/#une-structure-hierarchique","title":"Une structure hi\u00e9rarchique ?","text":"<p>Exemple : La hi\u00e9rarchie (organigramme) d'une entreprise :</p> <p></p>"},{"location":"terminale/arbres/vocabulaire/#les-arbres-pour-quoi-faire","title":"Les arbres, pour quoi faire ?","text":"<p>Exemple 1 : Lorsque l'interpr\u00e9teur Python lit un programme, il cr\u00e9e d'abord un arbre syntaxique utilisant la grammaire du langage. On ne pourrait en effet pas stocker ces donn\u00e9es dans une structure lin\u00e9aire sans y perdre la structuration du programme.</p> <pre><code>def produit(a: int, b: int) -&gt; int:\ns = 0\nfor i in range(b):\ns = s + a\nreturn s\n</code></pre> <p></p> <p>Exemple 2 : Arbre d'une page HTML</p> <p><pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;title&gt;Ma superbe page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Mon super titre&lt;/h1&gt;\n&lt;p&gt;Mon super paragraphe&lt;/p&gt;\n&lt;img src=\"mon_image.png\" alt=\"ma superbe image\" /&gt;\n&lt;/body&gt;\n&lt;footer&gt;\n&lt;p&gt;Un pied de page&lt;/p&gt;\n&lt;/footer&gt;\n&lt;/html&gt;\n</code></pre> </p> <p>Exemple 3 : Arborescence des fichiers sur Linux Source : pixees</p> <p></p>"},{"location":"terminale/arbres/vocabulaire/#les-arbres","title":"Les arbres","text":""},{"location":"terminale/arbres/vocabulaire/#definition","title":"D\u00e9finition","text":"<p>Arbre : ensemble de noeuds organis\u00e9s de fa\u00e7on hi\u00e9rarchique \u00e0 partir d'un noeud appel\u00e9 racine.</p> <p>Un arbre est une structure de donn\u00e9es :</p> <ul> <li>hi\u00e9rarchique</li> <li>naturellement r\u00e9cursive</li> </ul>"},{"location":"terminale/arbres/vocabulaire/#vocabulaire","title":"Vocabulaire","text":"<ul> <li>Un noeud est caract\u00e9ris\u00e9 par :<ul> <li>une \u00e9tiquette (= valeur ou cl\u00e9 associ\u00e9e au noeud) si l'arbre est \u00e9tiquet\u00e9,</li> <li>un nombre fini de fils.</li> </ul> </li> <li>Le noeud initial est appel\u00e9 racine de l'arbre.</li> <li>Un noeud :<ul> <li>est reli\u00e9 \u00e0 un noeud p\u00e8re par une ar\u00eate (parfois appel\u00e9e branche) SAUF le noeud racine.</li> <li>peut avoir une ou plusieurs ar\u00eates sortantes le reliant \u00e0 ses noeuds fils.</li> <li>est appel\u00e9 feuille s'il n'a pas de fils.</li> </ul> </li> </ul> <ul> <li>chemin - deux conventions :<ul> <li>suite de noeuds cons\u00e9cutifs de l'arbre, de longueur \u00e9gale au nombre de noeuds du chemin. Sur l'arbre suivant, un chemin allant de A \u00e0 H serait <code>[A, C, E, H]</code> (longueur du chemin : 4). OU</li> <li>suite d'ar\u00eates cons\u00e9cutives de l'arbre, de longueur \u00e9gale au nombre d'ar\u00eates du chemin.Sur l'arbre suivant, un chemin allant de A \u00e0 H serait <code>[A-&gt;C, C-&gt;E, E-&gt;H]</code> (longueur du chemin : 3).</li> </ul> </li> </ul>"},{"location":"terminale/arbres/vocabulaire/#quelques-mesures-sur-les-arbres","title":"Quelques mesures sur les arbres","text":"<ul> <li> <p>taille d'un arbre : nombre de noeuds de l\u2019arbreL'arbre ci-dessous a une taille de 8 (car 8 noeuds).</p> </li> <li> <p>profondeur d\u2019un noeud - deux conventions :</p> <ul> <li>nombre de noeuds rencontr\u00e9s pour aller de la racine jusqu'\u00e0 ce noeudSur l'arbre ci-dessous, la profondeur du noeud H est de 4. OU</li> <li>nombre d\u2019ar\u00eates rencontr\u00e9es pour aller de la racine jusqu'\u00e0 ce noeudSur l'arbre ci-dessous, la profondeur du noeud H est de 3.</li> </ul> </li> <li> <p>hauteur d\u2019un arbre : deux conventions :</p> <ul> <li>profondeur maximale des feuilles de l\u2019arbre (d\u00e9pend de la convention choisie pour la profondeur.)Sur l'arbre ci-dessous, la hauteur de l'arbre est la profondeur du noeud H, elle est donc de 4 ou de 3 selon la convention choisie.</li> </ul> </li> <li> <p>arit\u00e9/degr\u00e9 d\u2019un noeud : nombre de fils du noeud.</p> </li> <li> <p>arit\u00e9/degr\u00e9 d\u2019un arbre : nombre maximal de fils des noeuds de l\u2019arbre.</p> </li> </ul> <p></p>"},{"location":"terminale/arbres/vocabulaire/#les-arbres-binaires","title":"Les arbres binaires","text":""},{"location":"terminale/arbres/vocabulaire/#definition_1","title":"D\u00e9finition","text":"<p>Un arbre binaire est : - soit un arbre vide, qui ne contient aucun noeud, - soit un arbre poss\u00e9dant un noeud, appel\u00e9 la racine de l'arbre, reli\u00e9 \u00e0 exactement deux arbres binaires, respectivement appel\u00e9s sous-arbre gauche et sous-arbre droit (pouvant \u00eatre vides).</p> <p>La racine d'un arbre binaire est reli\u00e9e \u00e0 la racine du sous-arbre gauche et \u00e0 la racine du sous-arbre droit (lorsqu'ils ne sont pas vides).</p> <p>Un arbre binaire poss\u00e8de les particularit\u00e9s suivantes qui le distinguent d'un arbre enracin\u00e9 :</p> <ul> <li>Il peut \u00eatre un arbre vide</li> <li>Il poss\u00e8de TOUJOURS deux sous-arbres (qui peuvent \u00eatre vides ou mener au noeud racine du sous-arbre)</li> <li>La racine d'un arbre binaire poss\u00e8de 0, 1 ou 2 noeuds fils.</li> <li>Le placement des \u00e9l\u00e9ments \u00e0 gauche ou \u00e0 droite doit suivre une logique interne et n'est pas al\u00e9atoire.</li> </ul> <p></p>"},{"location":"terminale/arbres/vocabulaire/#arbres-binaires-particuliers","title":"Arbres binaires particuliers","text":"<p>Source : http://pascal.delahaye1.free.fr/cpge/informatique/cours%20projetes/cp08.pdf</p> <p></p> <ul> <li> <p>Un arbre binaire filiforme (ou d\u00e9g\u00e9n\u00e9r\u00e9) est un arbre dans lequel tous les noeuds internes n\u2019ont qu\u2019un seul fils. (Un arbre filiforme ne poss\u00e8de donc qu\u2019une seule feuille.)</p> </li> <li> <p>Un arbre binaire localement complet (ou arbre binaire strict) est un arbre binaire dont tous les noeuds internes poss\u00e8dent exactement z\u00e9ro ou deux fils (l'arbre vide n'est pas localement complet).</p> </li> <li> <p>Un peigne gauche (respectivement peigne droit) est un arbre binaire localement complet dans lequel tout fils droit (respectivement gauche) est une feuille.</p> </li> <li> <p>Un arbre binaire parfait est un arbre binaire localement complet dans lequel tous les niveaux sont remplis (toutes les feuilles sont \u00e0 la m\u00eame profondeur).</p> </li> <li> <p>Un arbre binaire complet (ou presque complet) est un arbre binaire dans lequel tous les niveaux sont remplis \u00e0 l\u2019exception \u00e9ventuelle du dernier, auquel cas les feuilles du dernier niveau sont align\u00e9es \u00e0 gauche.</p> </li> <li> <p>Un arbre binaire \u00e9quilibr\u00e9 est un arbre binaire tel que pour chaque noeud, le sous-arbre gauche et le sous-arbre droit ont une hauteur qui ne diff\u00e8re que de 1 au plus.</p> </li> </ul>"},{"location":"terminale/arbres/vocabulaire/#relations-entre-taille-n-et-hauteur-h","title":"Relations entre taille n et hauteur h","text":""},{"location":"terminale/arbres/vocabulaire/#encadrement-avec-une-profondeur-0-pour-la-racine","title":"Encadrement avec une profondeur 0 pour la racine\u00a0:","text":"<ul> <li>Pour une taille n donn\u00e9e : \\(\\lfloor log_{2}(n) \\rfloor \\leq h \\leq n-1\\)<ul> <li>h est minimale lorsque l'arbre est complet (ou parfait), h est maximale lorsque l'arbre est filiforme</li> <li>exemple si \\(n=12\\) : \\(3 \\leq h \\leq 11\\)</li> </ul> </li> <li>Pour une hauteur h donn\u00e9e : \\(h+1 \\leq n \\leq 2^{h+1}-1\\)<ul> <li>n est minimale lorsque l'arbre est filiforme, n est maximale lorsque l'arbre est parfait</li> <li>exemple si \\(h=5\\) : \\(6 \\leq h \\leq 63\\)</li> </ul> </li> </ul>"},{"location":"terminale/arbres/vocabulaire/#encadrement-avec-une-profondeur-1-pour-la-racine","title":"Encadrement avec une profondeur 1 pour la racine\u00a0:","text":"<ul> <li>Pour une taille n donn\u00e9e : \\(\\lceil log_{2}(n+1) \\rceil \\leq h \\leq n\\)<ul> <li>h est minimale lorsque l'arbre est complet (ou parfait), h est maximale lorsque l'arbre est filiforme</li> <li>exemple si \\(n=12\\) : \\(4 \\leq h \\leq 12\\)</li> </ul> </li> <li>Pour une hauteur h donn\u00e9e : \\(h \\leq n \\leq 2^{h}-1\\)<ul> <li>n est minimale lorsque l'arbre est filiforme, n est maximale lorsque l'arbre est parfait</li> <li>exemple si \\(h=5\\) : \\(5 \\leq h \\leq 31\\)</li> </ul> </li> </ul>"}]}